{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Chess = exports.validateFen = exports.SQUARES = exports.DEFAULT_POSITION = exports.KING = exports.QUEEN = exports.ROOK = exports.BISHOP = exports.KNIGHT = exports.PAWN = exports.BLACK = exports.WHITE = void 0;\nexports.WHITE = 'w';\nexports.BLACK = 'b';\nexports.PAWN = 'p';\nexports.KNIGHT = 'n';\nexports.BISHOP = 'b';\nexports.ROOK = 'r';\nexports.QUEEN = 'q';\nexports.KING = 'k';\nexports.DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nconst EMPTY = -1;\nconst FLAGS = {\n  NORMAL: 'n',\n  CAPTURE: 'c',\n  BIG_PAWN: 'b',\n  EP_CAPTURE: 'e',\n  PROMOTION: 'p',\n  KSIDE_CASTLE: 'k',\n  QSIDE_CASTLE: 'q'\n}; // prettier-ignore\n\nexports.SQUARES = ['a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8', 'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7', 'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6', 'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5', 'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4', 'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3', 'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2', 'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'];\nconst BITS = {\n  NORMAL: 1,\n  CAPTURE: 2,\n  BIG_PAWN: 4,\n  EP_CAPTURE: 8,\n  PROMOTION: 16,\n  KSIDE_CASTLE: 32,\n  QSIDE_CASTLE: 64\n};\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n// prettier-ignore\n// eslint-disable-next-line\n\nconst Ox88 = {\n  a8: 0,\n  b8: 1,\n  c8: 2,\n  d8: 3,\n  e8: 4,\n  f8: 5,\n  g8: 6,\n  h8: 7,\n  a7: 16,\n  b7: 17,\n  c7: 18,\n  d7: 19,\n  e7: 20,\n  f7: 21,\n  g7: 22,\n  h7: 23,\n  a6: 32,\n  b6: 33,\n  c6: 34,\n  d6: 35,\n  e6: 36,\n  f6: 37,\n  g6: 38,\n  h6: 39,\n  a5: 48,\n  b5: 49,\n  c5: 50,\n  d5: 51,\n  e5: 52,\n  f5: 53,\n  g5: 54,\n  h5: 55,\n  a4: 64,\n  b4: 65,\n  c4: 66,\n  d4: 67,\n  e4: 68,\n  f4: 69,\n  g4: 70,\n  h4: 71,\n  a3: 80,\n  b3: 81,\n  c3: 82,\n  d3: 83,\n  e3: 84,\n  f3: 85,\n  g3: 86,\n  h3: 87,\n  a2: 96,\n  b2: 97,\n  c2: 98,\n  d2: 99,\n  e2: 100,\n  f2: 101,\n  g2: 102,\n  h2: 103,\n  a1: 112,\n  b1: 113,\n  c1: 114,\n  d1: 115,\n  e1: 116,\n  f1: 117,\n  g1: 118,\n  h1: 119\n};\nconst PAWN_OFFSETS = {\n  b: [16, 32, 17, 15],\n  w: [-16, -32, -17, -15]\n};\nconst PIECE_OFFSETS = {\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\n  b: [-17, -15, 17, 15],\n  r: [-16, 1, 16, -1],\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\n  k: [-17, -16, -15, 1, 17, 16, 15, -1]\n}; // prettier-ignore\n\nconst ATTACKS = [20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20]; // prettier-ignore\n\nconst RAYS = [17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0, 0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0, 0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0, -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17];\nconst PIECE_MASKS = {\n  p: 0x1,\n  n: 0x2,\n  b: 0x4,\n  r: 0x8,\n  q: 0x10,\n  k: 0x20\n};\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [exports.KNIGHT, exports.BISHOP, exports.ROOK, exports.QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\n\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst ROOKS = {\n  w: [{\n    square: Ox88.a1,\n    flag: BITS.QSIDE_CASTLE\n  }, {\n    square: Ox88.h1,\n    flag: BITS.KSIDE_CASTLE\n  }],\n  b: [{\n    square: Ox88.a8,\n    flag: BITS.QSIDE_CASTLE\n  }, {\n    square: Ox88.h8,\n    flag: BITS.KSIDE_CASTLE\n  }]\n};\nconst SECOND_RANK = {\n  b: RANK_7,\n  w: RANK_2\n};\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*']; // Extracts the zero-based rank of an 0x88 square.\n\nfunction rank(square) {\n  return square >> 4;\n} // Extracts the zero-based file of an 0x88 square.\n\n\nfunction file(square) {\n  return square & 0xf;\n}\n\nfunction isDigit(c) {\n  return '0123456789'.indexOf(c) !== -1;\n} // Converts a 0x88 square to algebraic notation.\n\n\nfunction algebraic(square) {\n  const f = file(square);\n  const r = rank(square);\n  return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);\n}\n\nfunction swapColor(color) {\n  return color === exports.WHITE ? exports.BLACK : exports.WHITE;\n}\n\nfunction validateFen(fen) {\n  // 1st criterion: 6 space-seperated fields?\n  const tokens = fen.split(/\\s+/);\n\n  if (tokens.length !== 6) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: must contain six space-delimited fields'\n    };\n  } // 2nd criterion: move number field is a integer value > 0?\n\n\n  const moveNumber = parseInt(tokens[5], 10);\n\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: move number must be a positive integer'\n    };\n  } // 3rd criterion: half move counter is an integer >= 0?\n\n\n  const halfMoves = parseInt(tokens[4], 10);\n\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: half move counter number must be a non-negative integer'\n    };\n  } // 4th criterion: 4th field is a valid e.p.-string?\n\n\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: en-passant square is invalid'\n    };\n  } // 5th criterion: 3th field is a valid castle-string?\n\n\n  if (/[^kKqQ-]/.test(tokens[2])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: castling availability is invalid'\n    };\n  } // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n\n\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: side-to-move is invalid'\n    };\n  } // 7th criterion: 1st field contains 8 rows?\n\n\n  const rows = tokens[0].split('/');\n\n  if (rows.length !== 8) {\n    return {\n      ok: false,\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\"\n    };\n  } // 8th criterion: every row is valid?\n\n\n  for (let i = 0; i < rows.length; i++) {\n    // check for right sum of fields AND not two numbers in succession\n    let sumFields = 0;\n    let previousWasNumber = false;\n\n    for (let k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (consecutive number)'\n          };\n        }\n\n        sumFields += parseInt(rows[i][k], 10);\n        previousWasNumber = true;\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (invalid piece)'\n          };\n        }\n\n        sumFields += 1;\n        previousWasNumber = false;\n      }\n    }\n\n    if (sumFields !== 8) {\n      return {\n        ok: false,\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)'\n      };\n    }\n  }\n\n  if (tokens[3][1] == '3' && tokens[1] == 'w' || tokens[3][1] == '6' && tokens[1] == 'b') {\n    return {\n      ok: false,\n      error: 'Invalid FEN: illegal en-passant square'\n    };\n  }\n\n  const kings = [{\n    color: 'white',\n    regex: /K/g\n  }, {\n    color: 'black',\n    regex: /k/g\n  }];\n\n  for (const {\n    color,\n    regex\n  } of kings) {\n    if (!regex.test(tokens[0])) {\n      return {\n        ok: false,\n        error: `Invalid FEN: missing ${color} king`\n      };\n    }\n\n    if ((tokens[0].match(regex) || []).length > 1) {\n      return {\n        ok: false,\n        error: `Invalid FEN: too many ${color} kings`\n      };\n    }\n  }\n\n  return {\n    ok: true\n  };\n}\n\nexports.validateFen = validateFen; // this function is used to uniquely identify ambiguous moves\n\nfunction getDisambiguator(move, moves) {\n  const from = move.from;\n  const to = move.to;\n  const piece = move.piece;\n  let ambiguities = 0;\n  let sameRank = 0;\n  let sameFile = 0;\n\n  for (let i = 0, len = moves.length; i < len; i++) {\n    const ambigFrom = moves[i].from;\n    const ambigTo = moves[i].to;\n    const ambigPiece = moves[i].piece;\n    /*\n     * if a move of the same piece type ends on the same to square, we'll need\n     * to add a disambiguator to the algebraic notation\n     */\n\n    if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n      ambiguities++;\n\n      if (rank(from) === rank(ambigFrom)) {\n        sameRank++;\n      }\n\n      if (file(from) === file(ambigFrom)) {\n        sameFile++;\n      }\n    }\n  }\n\n  if (ambiguities > 0) {\n    if (sameRank > 0 && sameFile > 0) {\n      /*\n       * if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      return algebraic(from);\n    } else if (sameFile > 0) {\n      /*\n       * if the moving piece rests on the same file, use the rank symbol as the\n       * disambiguator\n       */\n      return algebraic(from).charAt(1);\n    } else {\n      // else use the file symbol\n      return algebraic(from).charAt(0);\n    }\n  }\n\n  return '';\n}\n\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n  const r = rank(to);\n\n  if (piece === exports.PAWN && (r === RANK_1 || r === RANK_8)) {\n    for (let i = 0; i < PROMOTIONS.length; i++) {\n      const promotion = PROMOTIONS[i];\n      moves.push({\n        color,\n        from,\n        to,\n        piece,\n        captured,\n        promotion,\n        flags: flags | BITS.PROMOTION\n      });\n    }\n  } else {\n    moves.push({\n      color,\n      from,\n      to,\n      piece,\n      captured,\n      flags\n    });\n  }\n}\n\nfunction inferPieceType(san) {\n  let pieceType = san.charAt(0);\n\n  if (pieceType >= 'a' && pieceType <= 'h') {\n    const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n\n    if (matches) {\n      return undefined;\n    }\n\n    return exports.PAWN;\n  }\n\n  pieceType = pieceType.toLowerCase();\n\n  if (pieceType === 'o') {\n    return exports.KING;\n  }\n\n  return pieceType;\n} // parses all of the decorators out of a SAN string\n\n\nfunction strippedSan(move) {\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\n\nclass Chess {\n  constructor(fen = exports.DEFAULT_POSITION) {\n    this._board = new Array(128);\n    this._turn = exports.WHITE;\n    this._header = {};\n    this._kings = {\n      w: EMPTY,\n      b: EMPTY\n    };\n    this._epSquare = -1;\n    this._halfMoves = 0;\n    this._moveNumber = 0;\n    this._history = [];\n    this._comments = {};\n    this._castling = {\n      w: 0,\n      b: 0\n    };\n    this.load(fen);\n  }\n\n  clear(keepHeaders = false) {\n    this._board = new Array(128);\n    this._kings = {\n      w: EMPTY,\n      b: EMPTY\n    };\n    this._turn = exports.WHITE;\n    this._castling = {\n      w: 0,\n      b: 0\n    };\n    this._epSquare = EMPTY;\n    this._halfMoves = 0;\n    this._moveNumber = 1;\n    this._history = [];\n    this._comments = {};\n    this._header = keepHeaders ? this._header : {};\n\n    this._updateSetup(this.fen());\n  }\n\n  load(fen, keepHeaders = false) {\n    let tokens = fen.split(/\\s+/); // append commonly omitted fen tokens\n\n    if (tokens.length >= 2 && tokens.length < 6) {\n      const adjustments = ['-', '-', '0', '1'];\n      fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n    }\n\n    tokens = fen.split(/\\s+/);\n    const {\n      ok,\n      error\n    } = validateFen(fen);\n\n    if (!ok) {\n      throw new Error(error);\n    }\n\n    const position = tokens[0];\n    let square = 0;\n    this.clear(keepHeaders);\n\n    for (let i = 0; i < position.length; i++) {\n      const piece = position.charAt(i);\n\n      if (piece === '/') {\n        square += 8;\n      } else if (isDigit(piece)) {\n        square += parseInt(piece, 10);\n      } else {\n        const color = piece < 'a' ? exports.WHITE : exports.BLACK;\n        this.put({\n          type: piece.toLowerCase(),\n          color\n        }, algebraic(square));\n        square++;\n      }\n    }\n\n    this._turn = tokens[1];\n\n    if (tokens[2].indexOf('K') > -1) {\n      this._castling.w |= BITS.KSIDE_CASTLE;\n    }\n\n    if (tokens[2].indexOf('Q') > -1) {\n      this._castling.w |= BITS.QSIDE_CASTLE;\n    }\n\n    if (tokens[2].indexOf('k') > -1) {\n      this._castling.b |= BITS.KSIDE_CASTLE;\n    }\n\n    if (tokens[2].indexOf('q') > -1) {\n      this._castling.b |= BITS.QSIDE_CASTLE;\n    }\n\n    this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n    this._halfMoves = parseInt(tokens[4], 10);\n    this._moveNumber = parseInt(tokens[5], 10);\n\n    this._updateSetup(this.fen());\n  }\n\n  fen() {\n    var _a, _b;\n\n    let empty = 0;\n    let fen = '';\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i]) {\n        if (empty > 0) {\n          fen += empty;\n          empty = 0;\n        }\n\n        const {\n          color,\n          type: piece\n        } = this._board[i];\n        fen += color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\n      } else {\n        empty++;\n      }\n\n      if (i + 1 & 0x88) {\n        if (empty > 0) {\n          fen += empty;\n        }\n\n        if (i !== Ox88.h1) {\n          fen += '/';\n        }\n\n        empty = 0;\n        i += 8;\n      }\n    }\n\n    let castling = '';\n\n    if (this._castling[exports.WHITE] & BITS.KSIDE_CASTLE) {\n      castling += 'K';\n    }\n\n    if (this._castling[exports.WHITE] & BITS.QSIDE_CASTLE) {\n      castling += 'Q';\n    }\n\n    if (this._castling[exports.BLACK] & BITS.KSIDE_CASTLE) {\n      castling += 'k';\n    }\n\n    if (this._castling[exports.BLACK] & BITS.QSIDE_CASTLE) {\n      castling += 'q';\n    } // do we have an empty castling flag?\n\n\n    castling = castling || '-';\n    let epSquare = '-';\n    /*\n     * only print the ep square if en passant is a valid move (pawn is present\n     * and ep capture is not pinned)\n     */\n\n    if (this._epSquare !== EMPTY) {\n      const bigPawnSquare = this._epSquare + (this._turn === exports.WHITE ? 16 : -16);\n      const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n\n      for (const square of squares) {\n        // is the square off the board?\n        if (square & 0x88) {\n          continue;\n        }\n\n        const color = this._turn; // is there a pawn that can capture the epSquare?\n\n        if (((_a = this._board[square]) === null || _a === void 0 ? void 0 : _a.color) === color && ((_b = this._board[square]) === null || _b === void 0 ? void 0 : _b.type) === exports.PAWN) {\n          // if the pawn makes an ep capture, does it leave it's king in check?\n          this._makeMove({\n            color,\n            from: square,\n            to: this._epSquare,\n            piece: exports.PAWN,\n            captured: exports.PAWN,\n            flags: BITS.EP_CAPTURE\n          });\n\n          const isLegal = !this._isKingAttacked(color);\n\n          this._undoMove(); // if ep is legal, break and set the ep square in the FEN output\n\n\n          if (isLegal) {\n            epSquare = algebraic(this._epSquare);\n            break;\n          }\n        }\n      }\n    }\n\n    return [fen, this._turn, castling, epSquare, this._halfMoves, this._moveNumber].join(' ');\n  }\n  /*\n   * Called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object. If the FEN\n   * is equal to the default position, the SetUp and FEN are deleted the setup\n   * is only updated if history.length is zero, ie moves haven't been made.\n   */\n\n\n  _updateSetup(fen) {\n    if (this._history.length > 0) return;\n\n    if (fen !== exports.DEFAULT_POSITION) {\n      this._header['SetUp'] = '1';\n      this._header['FEN'] = fen;\n    } else {\n      delete this._header['SetUp'];\n      delete this._header['FEN'];\n    }\n  }\n\n  reset() {\n    this.load(exports.DEFAULT_POSITION);\n  }\n\n  get(square) {\n    return this._board[Ox88[square]] || false;\n  }\n\n  put({\n    type,\n    color\n  }, square) {\n    // check for piece\n    if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n      return false;\n    } // check for valid square\n\n\n    if (!(square in Ox88)) {\n      return false;\n    }\n\n    const sq = Ox88[square]; // don't let the user place more than one king\n\n    if (type == exports.KING && !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n      return false;\n    }\n\n    this._board[sq] = {\n      type: type,\n      color: color\n    };\n\n    if (type === exports.KING) {\n      this._kings[color] = sq;\n    }\n\n    this._updateSetup(this.fen());\n\n    return true;\n  }\n\n  remove(square) {\n    const piece = this.get(square);\n    delete this._board[Ox88[square]];\n\n    if (piece && piece.type === exports.KING) {\n      this._kings[piece.color] = EMPTY;\n    }\n\n    this._updateSetup(this.fen());\n\n    return piece;\n  }\n\n  _attacked(color, square) {\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // did we run off the end of the board\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      } // if empty square or wrong color\n\n\n      if (this._board[i] === undefined || this._board[i].color !== color) {\n        continue;\n      }\n\n      const piece = this._board[i];\n      const difference = i - square; // skip - to/from square are the same\n\n      if (difference === 0) {\n        continue;\n      }\n\n      const index = difference + 119;\n\n      if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n        if (piece.type === exports.PAWN) {\n          if (difference > 0) {\n            if (piece.color === exports.WHITE) return true;\n          } else {\n            if (piece.color === exports.BLACK) return true;\n          }\n\n          continue;\n        } // if the piece is a knight or a king\n\n\n        if (piece.type === 'n' || piece.type === 'k') return true;\n        const offset = RAYS[index];\n        let j = i + offset;\n        let blocked = false;\n\n        while (j !== square) {\n          if (this._board[j] != null) {\n            blocked = true;\n            break;\n          }\n\n          j += offset;\n        }\n\n        if (!blocked) return true;\n      }\n    }\n\n    return false;\n  }\n\n  _isKingAttacked(color) {\n    return this._attacked(swapColor(color), this._kings[color]);\n  }\n\n  isAttacked(square, attackedBy) {\n    return this._attacked(attackedBy, Ox88[square]);\n  }\n\n  isCheck() {\n    return this._isKingAttacked(this._turn);\n  }\n\n  inCheck() {\n    return this.isCheck();\n  }\n\n  isCheckmate() {\n    return this.isCheck() && this._moves().length === 0;\n  }\n\n  isStalemate() {\n    return !this.isCheck() && this._moves().length === 0;\n  }\n\n  isInsufficientMaterial() {\n    /*\n     * k.b. vs k.b. (of opposite colors) with mate in 1:\n     * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n     *\n     * k.b. vs k.n. with mate in 1:\n     * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n     */\n    const pieces = {\n      b: 0,\n      n: 0,\n      r: 0,\n      q: 0,\n      k: 0,\n      p: 0\n    };\n    const bishops = [];\n    let numPieces = 0;\n    let squareColor = 0;\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      squareColor = (squareColor + 1) % 2;\n\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n\n      const piece = this._board[i];\n\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n\n        if (piece.type === exports.BISHOP) {\n          bishops.push(squareColor);\n        }\n\n        numPieces++;\n      }\n    } // k vs. k\n\n\n    if (numPieces === 2) {\n      return true;\n    } else if ( // k vs. kn .... or .... k vs. kb\n    numPieces === 3 && (pieces[exports.BISHOP] === 1 || pieces[exports.KNIGHT] === 1)) {\n      return true;\n    } else if (numPieces === pieces[exports.BISHOP] + 2) {\n      // kb vs. kb where any number of bishops are all on the same color\n      let sum = 0;\n      const len = bishops.length;\n\n      for (let i = 0; i < len; i++) {\n        sum += bishops[i];\n      }\n\n      if (sum === 0 || sum === len) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  isThreefoldRepetition() {\n    const moves = [];\n    const positions = {};\n    let repetition = false;\n\n    while (true) {\n      const move = this._undoMove();\n\n      if (!move) break;\n      moves.push(move);\n    }\n\n    while (true) {\n      /*\n       * remove the last two fields in the FEN string, they're not needed when\n       * checking for draw by rep\n       */\n      const fen = this.fen().split(' ').slice(0, 4).join(' '); // has the position occurred three or move times\n\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n\n      if (positions[fen] >= 3) {\n        repetition = true;\n      }\n\n      const move = moves.pop();\n\n      if (!move) {\n        break;\n      } else {\n        this._makeMove(move);\n      }\n    }\n\n    return repetition;\n  }\n\n  isDraw() {\n    return this._halfMoves >= 100 || // 50 moves per side = 100 half moves\n    this.isStalemate() || this.isInsufficientMaterial() || this.isThreefoldRepetition();\n  }\n\n  isGameOver() {\n    return this.isCheckmate() || this.isStalemate() || this.isDraw();\n  }\n\n  moves({\n    verbose = false,\n    square = undefined\n  } = {}) {\n    const moves = this._moves({\n      square\n    });\n\n    if (verbose) {\n      return moves.map(move => this._makePretty(move));\n    } else {\n      return moves.map(move => this._moveToSan(move, moves));\n    }\n  }\n\n  _moves({\n    legal = true,\n    piece = undefined,\n    square = undefined\n  } = {}) {\n    var _a;\n\n    const forSquare = square ? square.toLowerCase() : undefined;\n    const forPiece = piece === null || piece === void 0 ? void 0 : piece.toLowerCase();\n    const moves = [];\n    const us = this._turn;\n    const them = swapColor(us);\n    let firstSquare = Ox88.a8;\n    let lastSquare = Ox88.h1;\n    let singleSquare = false; // are we generating moves for a single square?\n\n    if (forSquare) {\n      // illegal square, return empty moves\n      if (!(forSquare in Ox88)) {\n        return [];\n      } else {\n        firstSquare = lastSquare = Ox88[forSquare];\n        singleSquare = true;\n      }\n    }\n\n    for (let from = firstSquare; from <= lastSquare; from++) {\n      // did we run off the end of the board\n      if (from & 0x88) {\n        from += 7;\n        continue;\n      } // empty square or opponent, skip\n\n\n      if (!this._board[from] || this._board[from].color === them) {\n        continue;\n      }\n\n      const {\n        type\n      } = this._board[from];\n      let to;\n\n      if (type === exports.PAWN) {\n        if (forPiece && forPiece !== type) continue; // single square, non-capturing\n\n        to = from + PAWN_OFFSETS[us][0];\n\n        if (!this._board[to]) {\n          addMove(moves, us, from, to, exports.PAWN); // double square\n\n          to = from + PAWN_OFFSETS[us][1];\n\n          if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n            addMove(moves, us, from, to, exports.PAWN, undefined, BITS.BIG_PAWN);\n          }\n        } // pawn captures\n\n\n        for (let j = 2; j < 4; j++) {\n          to = from + PAWN_OFFSETS[us][j];\n          if (to & 0x88) continue;\n\n          if (((_a = this._board[to]) === null || _a === void 0 ? void 0 : _a.color) === them) {\n            addMove(moves, us, from, to, exports.PAWN, this._board[to].type, BITS.CAPTURE);\n          } else if (to === this._epSquare) {\n            addMove(moves, us, from, to, exports.PAWN, exports.PAWN, BITS.EP_CAPTURE);\n          }\n        }\n      } else {\n        if (forPiece && forPiece !== type) continue;\n\n        for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n          const offset = PIECE_OFFSETS[type][j];\n          to = from;\n\n          while (true) {\n            to += offset;\n            if (to & 0x88) break;\n\n            if (!this._board[to]) {\n              addMove(moves, us, from, to, type);\n            } else {\n              // own color, stop loop\n              if (this._board[to].color === us) break;\n              addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n              break;\n            }\n            /* break, if knight or king */\n\n\n            if (type === exports.KNIGHT || type === exports.KING) break;\n          }\n        }\n      }\n    }\n    /*\n     * check for castling if we're:\n     *   a) generating all moves, or\n     *   b) doing single square move generation on the king's square\n     */\n\n\n    if (forPiece === undefined || forPiece === exports.KING) {\n      if (!singleSquare || lastSquare === this._kings[us]) {\n        // king-side castling\n        if (this._castling[us] & BITS.KSIDE_CASTLE) {\n          const castlingFrom = this._kings[us];\n          const castlingTo = castlingFrom + 2;\n\n          if (!this._board[castlingFrom + 1] && !this._board[castlingTo] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom + 1) && !this._attacked(them, castlingTo)) {\n            addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.KSIDE_CASTLE);\n          }\n        } // queen-side castling\n\n\n        if (this._castling[us] & BITS.QSIDE_CASTLE) {\n          const castlingFrom = this._kings[us];\n          const castlingTo = castlingFrom - 2;\n\n          if (!this._board[castlingFrom - 1] && !this._board[castlingFrom - 2] && !this._board[castlingFrom - 3] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom - 1) && !this._attacked(them, castlingTo)) {\n            addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.QSIDE_CASTLE);\n          }\n        }\n      }\n    }\n    /*\n     * return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n\n\n    if (!legal) {\n      return moves;\n    } // filter out illegal moves\n\n\n    const legalMoves = [];\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i]);\n\n      if (!this._isKingAttacked(us)) {\n        legalMoves.push(moves[i]);\n      }\n\n      this._undoMove();\n    }\n\n    return legalMoves;\n  }\n\n  move(move, {\n    strict = false\n  } = {}) {\n    /*\n     * The move function can be called with in the following parameters:\n     *\n     * .move('Nxb7')       <- argument is a case-sensitive SAN string\n     *\n     * .move({ from: 'h7', <- argument is a move object\n     *         to :'h8',\n     *         promotion: 'q' })\n     *\n     *\n     * An optional strict argument may be supplied to tell chess.js to\n     * strictly follow the SAN specification.\n     */\n    let moveObj = null;\n\n    if (typeof move === 'string') {\n      moveObj = this._moveFromSan(move, strict);\n    } else if (typeof move === 'object') {\n      const moves = this._moves(); // convert the pretty move object to an ugly move object\n\n\n      for (let i = 0, len = moves.length; i < len; i++) {\n        if (move.from === algebraic(moves[i].from) && move.to === algebraic(moves[i].to) && (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n          moveObj = moves[i];\n          break;\n        }\n      }\n    } // failed to find move\n\n\n    if (!moveObj) {\n      if (typeof move === 'string') {\n        throw new Error(`Invalid move: ${move}`);\n      } else {\n        throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n      }\n    }\n    /*\n     * need to make a copy of move because we can't generate SAN after the move\n     * is made\n     */\n\n\n    const prettyMove = this._makePretty(moveObj);\n\n    this._makeMove(moveObj);\n\n    return prettyMove;\n  }\n\n  _push(move) {\n    this._history.push({\n      move,\n      kings: {\n        b: this._kings.b,\n        w: this._kings.w\n      },\n      turn: this._turn,\n      castling: {\n        b: this._castling.b,\n        w: this._castling.w\n      },\n      epSquare: this._epSquare,\n      halfMoves: this._halfMoves,\n      moveNumber: this._moveNumber\n    });\n  }\n\n  _makeMove(move) {\n    const us = this._turn;\n    const them = swapColor(us);\n\n    this._push(move);\n\n    this._board[move.to] = this._board[move.from];\n    delete this._board[move.from]; // if ep capture, remove the captured pawn\n\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (this._turn === exports.BLACK) {\n        delete this._board[move.to - 16];\n      } else {\n        delete this._board[move.to + 16];\n      }\n    } // if pawn promotion, replace with new piece\n\n\n    if (move.promotion) {\n      this._board[move.to] = {\n        type: move.promotion,\n        color: us\n      };\n    } // if we moved the king\n\n\n    if (this._board[move.to].type === exports.KING) {\n      this._kings[us] = move.to; // if we castled, move the rook next to the king\n\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        const castlingTo = move.to - 1;\n        const castlingFrom = move.to + 1;\n        this._board[castlingTo] = this._board[castlingFrom];\n        delete this._board[castlingFrom];\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        const castlingTo = move.to + 1;\n        const castlingFrom = move.to - 2;\n        this._board[castlingTo] = this._board[castlingFrom];\n        delete this._board[castlingFrom];\n      } // turn off castling\n\n\n      this._castling[us] = 0;\n    } // turn off castling if we move a rook\n\n\n    if (this._castling[us]) {\n      for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (move.from === ROOKS[us][i].square && this._castling[us] & ROOKS[us][i].flag) {\n          this._castling[us] ^= ROOKS[us][i].flag;\n          break;\n        }\n      }\n    } // turn off castling if we capture a rook\n\n\n    if (this._castling[them]) {\n      for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (move.to === ROOKS[them][i].square && this._castling[them] & ROOKS[them][i].flag) {\n          this._castling[them] ^= ROOKS[them][i].flag;\n          break;\n        }\n      }\n    } // if big pawn move, update the en passant square\n\n\n    if (move.flags & BITS.BIG_PAWN) {\n      if (us === exports.BLACK) {\n        this._epSquare = move.to - 16;\n      } else {\n        this._epSquare = move.to + 16;\n      }\n    } else {\n      this._epSquare = EMPTY;\n    } // reset the 50 move counter if a pawn is moved or a piece is captured\n\n\n    if (move.piece === exports.PAWN) {\n      this._halfMoves = 0;\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      this._halfMoves = 0;\n    } else {\n      this._halfMoves++;\n    }\n\n    if (us === exports.BLACK) {\n      this._moveNumber++;\n    }\n\n    this._turn = them;\n  }\n\n  undo() {\n    const move = this._undoMove();\n\n    return move ? this._makePretty(move) : null;\n  }\n\n  _undoMove() {\n    const old = this._history.pop();\n\n    if (old === undefined) {\n      return null;\n    }\n\n    const move = old.move;\n    this._kings = old.kings;\n    this._turn = old.turn;\n    this._castling = old.castling;\n    this._epSquare = old.epSquare;\n    this._halfMoves = old.halfMoves;\n    this._moveNumber = old.moveNumber;\n    const us = this._turn;\n    const them = swapColor(us);\n    this._board[move.from] = this._board[move.to];\n    this._board[move.from].type = move.piece; // to undo any promotions\n\n    delete this._board[move.to];\n\n    if (move.captured) {\n      if (move.flags & BITS.EP_CAPTURE) {\n        // en passant capture\n        let index;\n\n        if (us === exports.BLACK) {\n          index = move.to - 16;\n        } else {\n          index = move.to + 16;\n        }\n\n        this._board[index] = {\n          type: exports.PAWN,\n          color: them\n        };\n      } else {\n        // regular capture\n        this._board[move.to] = {\n          type: move.captured,\n          color: them\n        };\n      }\n    }\n\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      let castlingTo, castlingFrom;\n\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castlingTo = move.to + 1;\n        castlingFrom = move.to - 1;\n      } else {\n        castlingTo = move.to - 2;\n        castlingFrom = move.to + 1;\n      }\n\n      this._board[castlingTo] = this._board[castlingFrom];\n      delete this._board[castlingFrom];\n    }\n\n    return move;\n  }\n\n  pgn({\n    newline = '\\n',\n    maxWidth = 0\n  } = {}) {\n    /*\n     * using the specification from http://www.chessclub.com/help/PGN-spec\n     * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n     */\n    const result = [];\n    let headerExists = false;\n    /* add the PGN header information */\n\n    for (const i in this._header) {\n      /*\n       * TODO: order of enumerated properties in header object is not\n       * guaranteed, see ECMA-262 spec (section 12.6.4)\n       */\n      result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n      headerExists = true;\n    }\n\n    if (headerExists && this._history.length) {\n      result.push(newline);\n    }\n\n    const appendComment = moveString => {\n      const comment = this._comments[this.fen()];\n\n      if (typeof comment !== 'undefined') {\n        const delimiter = moveString.length > 0 ? ' ' : '';\n        moveString = `${moveString}${delimiter}{${comment}}`;\n      }\n\n      return moveString;\n    }; // pop all of history onto reversed_history\n\n\n    const reversedHistory = [];\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove());\n    }\n\n    const moves = [];\n    let moveString = ''; // special case of a commented starting position with no moves\n\n    if (reversedHistory.length === 0) {\n      moves.push(appendComment(''));\n    } // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n\n\n    while (reversedHistory.length > 0) {\n      moveString = appendComment(moveString);\n      const move = reversedHistory.pop(); // make TypeScript stop complaining about move being undefined\n\n      if (!move) {\n        break;\n      } // if the position started with black to move, start PGN with #. ...\n\n\n      if (!this._history.length && move.color === 'b') {\n        const prefix = `${this._moveNumber}. ...`; // is there a comment preceding the first move?\n\n        moveString = moveString ? `${moveString} ${prefix}` : prefix;\n      } else if (move.color === 'w') {\n        // store the previous generated move_string if we have one\n        if (moveString.length) {\n          moves.push(moveString);\n        }\n\n        moveString = this._moveNumber + '.';\n      }\n\n      moveString = moveString + ' ' + this._moveToSan(move, this._moves({\n        legal: true\n      }));\n\n      this._makeMove(move);\n    } // are there any other leftover moves?\n\n\n    if (moveString.length) {\n      moves.push(appendComment(moveString));\n    } // is there a result?\n\n\n    if (typeof this._header.Result !== 'undefined') {\n      moves.push(this._header.Result);\n    }\n    /*\n     * history should be back to what it was before we started generating PGN,\n     * so join together moves\n     */\n\n\n    if (maxWidth === 0) {\n      return result.join('') + moves.join(' ');\n    } // TODO (jah): huh?\n\n\n    const strip = function () {\n      if (result.length > 0 && result[result.length - 1] === ' ') {\n        result.pop();\n        return true;\n      }\n\n      return false;\n    }; // NB: this does not preserve comment whitespace.\n\n\n    const wrapComment = function (width, move) {\n      for (const token of move.split(' ')) {\n        if (!token) {\n          continue;\n        }\n\n        if (width + token.length > maxWidth) {\n          while (strip()) {\n            width--;\n          }\n\n          result.push(newline);\n          width = 0;\n        }\n\n        result.push(token);\n        width += token.length;\n        result.push(' ');\n        width++;\n      }\n\n      if (strip()) {\n        width--;\n      }\n\n      return width;\n    }; // wrap the PGN output at max_width\n\n\n    let currentWidth = 0;\n\n    for (let i = 0; i < moves.length; i++) {\n      if (currentWidth + moves[i].length > maxWidth) {\n        if (moves[i].includes('{')) {\n          currentWidth = wrapComment(currentWidth, moves[i]);\n          continue;\n        }\n      } // if the current move will push past max_width\n\n\n      if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n        // don't end the line with whitespace\n        if (result[result.length - 1] === ' ') {\n          result.pop();\n        }\n\n        result.push(newline);\n        currentWidth = 0;\n      } else if (i !== 0) {\n        result.push(' ');\n        currentWidth++;\n      }\n\n      result.push(moves[i]);\n      currentWidth += moves[i].length;\n    }\n\n    return result.join('');\n  }\n\n  header(...args) {\n    for (let i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        this._header[args[i]] = args[i + 1];\n      }\n    }\n\n    return this._header;\n  }\n\n  loadPgn(pgn, {\n    strict = false,\n    newlineChar = '\\r?\\n'\n  } = {}) {\n    function mask(str) {\n      return str.replace(/\\\\/g, '\\\\');\n    }\n\n    function parsePgnHeader(header) {\n      const headerObj = {};\n      const headers = header.split(new RegExp(mask(newlineChar)));\n      let key = '';\n      let value = '';\n\n      for (let i = 0; i < headers.length; i++) {\n        const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n        key = headers[i].replace(regex, '$1');\n        value = headers[i].replace(regex, '$2');\n\n        if (key.trim().length > 0) {\n          headerObj[key] = value;\n        }\n      }\n\n      return headerObj;\n    } // strip whitespace from head/tail of PGN block\n\n\n    pgn = pgn.trim();\n    /*\n     * RegExp to split header. Takes advantage of the fact that header and movetext\n     * will always have a blank line between them (ie, two newline_char's). Handles\n     * case where movetext is empty by matching newlineChar until end of string is\n     * matched - effectively trimming from the end extra newlineChar.\n     *\n     * With default newline_char, will equal:\n     * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n     */\n\n    const headerRegex = new RegExp('^(\\\\[((?:' + mask(newlineChar) + ')|.)*\\\\])' + '((?:\\\\s*' + mask(newlineChar) + '){2}|(?:\\\\s*' + mask(newlineChar) + ')*$)'); // If no header given, begin with moves.\n\n    const headerRegexResults = headerRegex.exec(pgn);\n    const headerString = headerRegexResults ? headerRegexResults.length >= 2 ? headerRegexResults[1] : '' : ''; // Put the board in the starting position\n\n    this.reset(); // parse PGN header\n\n    const headers = parsePgnHeader(headerString);\n    let fen = '';\n\n    for (const key in headers) {\n      // check to see user is including fen (possibly with wrong tag case)\n      if (key.toLowerCase() === 'fen') {\n        fen = headers[key];\n      }\n\n      this.header(key, headers[key]);\n    }\n    /*\n     * the permissive parser should attempt to load a fen tag, even if it's the\n     * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n     */\n\n\n    if (!strict) {\n      if (fen) {\n        this.load(fen, true);\n      }\n    } else {\n      /*\n       * strict parser - load the starting position indicated by [Setup '1']\n       * and [FEN position]\n       */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers)) {\n          throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n        } // second argument to load: don't clear the headers\n\n\n        this.load(headers['FEN'], true);\n      }\n    }\n    /*\n     * NB: the regexes below that delete move numbers, recursive annotations,\n     * and numeric annotation glyphs may also match text in comments. To\n     * prevent this, we transform comments by hex-encoding them in place and\n     * decoding them again after the other tokens have been deleted.\n     *\n     * While the spec states that PGN files should be ASCII encoded, we use\n     * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n     * for modern users\n     */\n\n\n    function toHex(s) {\n      return Array.from(s).map(function (c) {\n        /*\n         * encodeURI doesn't transform most ASCII characters, so we handle\n         * these ourselves\n         */\n        return c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n      }).join('');\n    }\n\n    function fromHex(s) {\n      return s.length == 0 ? '' : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n    }\n\n    const encodeComment = function (s) {\n      s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n      return `{${toHex(s.slice(1, s.length - 1))}}`;\n    };\n\n    const decodeComment = function (s) {\n      if (s.startsWith('{') && s.endsWith('}')) {\n        return fromHex(s.slice(1, s.length - 1));\n      }\n    }; // delete header to get the moves\n\n\n    let ms = pgn.replace(headerString, '').replace( // encode comments so they don't get deleted below\n    new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {\n      return bracket !== undefined ? encodeComment(bracket) : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n    }).replace(new RegExp(mask(newlineChar), 'g'), ' '); // delete recursive annotation variations\n\n    const ravRegex = /(\\([^()]+\\))+?/g;\n\n    while (ravRegex.test(ms)) {\n      ms = ms.replace(ravRegex, '');\n    } // delete move numbers\n\n\n    ms = ms.replace(/\\d+\\.(\\.\\.)?/g, ''); // delete ... indicating black to move\n\n    ms = ms.replace(/\\.\\.\\./g, '');\n    /* delete numeric annotation glyphs */\n\n    ms = ms.replace(/\\$\\d+/g, ''); // trim and get array of moves\n\n    let moves = ms.trim().split(new RegExp(/\\s+/)); // delete empty entries\n\n    moves = moves.filter(move => move !== '');\n    let result = '';\n\n    for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n      const comment = decodeComment(moves[halfMove]);\n\n      if (comment !== undefined) {\n        this._comments[this.fen()] = comment;\n        continue;\n      }\n\n      const move = this._moveFromSan(moves[halfMove], strict); // invalid move\n\n\n      if (move == null) {\n        // was the move an end of game marker\n        if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n          result = moves[halfMove];\n        } else {\n          throw new Error(`Invalid move in PGN: ${moves[halfMove]}`);\n        }\n      } else {\n        // reset the end of game marker if making a valid move\n        result = '';\n\n        this._makeMove(move);\n      }\n    }\n    /*\n     * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n     * the termination marker. Only do this when headers are present, but the\n     * result tag is missing\n     */\n\n\n    if (result && Object.keys(this._header).length && !this._header['Result']) {\n      this.header('Result', result);\n    }\n  }\n  /*\n   * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} strict Use the strict SAN parser. It will throw errors\n   * on overly disambiguated moves (see below):\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n\n\n  _moveToSan(move, moves) {\n    let output = '';\n\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O';\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O';\n    } else {\n      if (move.piece !== exports.PAWN) {\n        const disambiguator = getDisambiguator(move, moves);\n        output += move.piece.toUpperCase() + disambiguator;\n      }\n\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === exports.PAWN) {\n          output += algebraic(move.from)[0];\n        }\n\n        output += 'x';\n      }\n\n      output += algebraic(move.to);\n\n      if (move.promotion) {\n        output += '=' + move.promotion.toUpperCase();\n      }\n    }\n\n    this._makeMove(move);\n\n    if (this.isCheck()) {\n      if (this.isCheckmate()) {\n        output += '#';\n      } else {\n        output += '+';\n      }\n    }\n\n    this._undoMove();\n\n    return output;\n  } // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n\n\n  _moveFromSan(move, strict = false) {\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\n    const cleanMove = strippedSan(move);\n    let pieceType = inferPieceType(cleanMove);\n\n    let moves = this._moves({\n      legal: true,\n      piece: pieceType\n    }); // strict parser\n\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n        return moves[i];\n      }\n    } // the strict parser failed\n\n\n    if (strict) {\n      return null;\n    }\n\n    let piece = undefined;\n    let matches = undefined;\n    let from = undefined;\n    let to = undefined;\n    let promotion = undefined;\n    /*\n     * The default permissive (non-strict) parser allows the user to parse\n     * non-standard chess notations. This parser is only run after the strict\n     * Standard Algebraic Notation (SAN) parser has failed.\n     *\n     * When running the permissive parser, we'll run a regex to grab the piece, the\n     * to/from square, and an optional promotion piece. This regex will\n     * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n     * f7f8q, b1c3\n     *\n     * NOTE: Some positions and moves may be ambiguous when using the permissive\n     * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n     * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n     * move). In these cases, the permissive parser will default to the most\n     * basic interpretation (which is b1c3 parsing to Nc3).\n     */\n\n    let overlyDisambiguated = false;\n    matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/ //     piece         from              to       promotion\n    );\n\n    if (matches) {\n      piece = matches[1];\n      from = matches[2];\n      to = matches[3];\n      promotion = matches[4];\n\n      if (from.length == 1) {\n        overlyDisambiguated = true;\n      }\n    } else {\n      /*\n       * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n       * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n       * there is one legal knight move to e7). In this case, the value of\n       * 'from' variable will be a rank or file, not a square.\n       */\n      matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n\n      if (matches) {\n        piece = matches[1];\n        from = matches[2];\n        to = matches[3];\n        promotion = matches[4];\n\n        if (from.length == 1) {\n          overlyDisambiguated = true;\n        }\n      }\n    }\n\n    pieceType = inferPieceType(cleanMove);\n    moves = this._moves({\n      legal: true,\n      piece: piece ? piece : pieceType\n    });\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (from && to) {\n        // hand-compare move properties with the results from our permissive regex\n        if ((!piece || piece.toLowerCase() == moves[i].piece) && Ox88[from] == moves[i].from && Ox88[to] == moves[i].to && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n          return moves[i];\n        } else if (overlyDisambiguated) {\n          /*\n           * SPECIAL CASE: we parsed a move string that may have an unneeded\n           * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n           */\n          const square = algebraic(moves[i].from);\n\n          if ((!piece || piece.toLowerCase() == moves[i].piece) && Ox88[to] == moves[i].to && (from == square[0] || from == square[1]) && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n            return moves[i];\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  ascii() {\n    let s = '   +------------------------+\\n';\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // display the rank\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |';\n      }\n\n      if (this._board[i]) {\n        const piece = this._board[i].type;\n        const color = this._board[i].color;\n        const symbol = color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\n        s += ' ' + symbol + ' ';\n      } else {\n        s += ' . ';\n      }\n\n      if (i + 1 & 0x88) {\n        s += '|\\n';\n        i += 8;\n      }\n    }\n\n    s += '   +------------------------+\\n';\n    s += '     a  b  c  d  e  f  g  h';\n    return s;\n  }\n\n  perft(depth) {\n    const moves = this._moves({\n      legal: false\n    });\n\n    let nodes = 0;\n    const color = this._turn;\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i]);\n\n      if (!this._isKingAttacked(color)) {\n        if (depth - 1 > 0) {\n          nodes += this.perft(depth - 1);\n        } else {\n          nodes++;\n        }\n      }\n\n      this._undoMove();\n    }\n\n    return nodes;\n  } // pretty = external move object\n\n\n  _makePretty(uglyMove) {\n    const {\n      color,\n      piece,\n      from,\n      to,\n      flags,\n      captured,\n      promotion\n    } = uglyMove;\n    let prettyFlags = '';\n\n    for (const flag in BITS) {\n      if (BITS[flag] & flags) {\n        prettyFlags += FLAGS[flag];\n      }\n    }\n\n    const fromAlgebraic = algebraic(from);\n    const toAlgebraic = algebraic(to);\n    const move = {\n      color,\n      piece,\n      from: fromAlgebraic,\n      to: toAlgebraic,\n      san: this._moveToSan(uglyMove, this._moves({\n        legal: true\n      })),\n      flags: prettyFlags,\n      lan: fromAlgebraic + toAlgebraic\n    };\n\n    if (captured) {\n      move.captured = captured;\n    }\n\n    if (promotion) {\n      move.promotion = promotion;\n      move.lan += promotion;\n    }\n\n    return move;\n  }\n\n  turn() {\n    return this._turn;\n  }\n\n  board() {\n    const output = [];\n    let row = [];\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i] == null) {\n        row.push(null);\n      } else {\n        row.push({\n          square: algebraic(i),\n          type: this._board[i].type,\n          color: this._board[i].color\n        });\n      }\n\n      if (i + 1 & 0x88) {\n        output.push(row);\n        row = [];\n        i += 8;\n      }\n    }\n\n    return output;\n  }\n\n  squareColor(square) {\n    if (square in Ox88) {\n      const sq = Ox88[square];\n      return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n    }\n\n    return null;\n  }\n\n  history({\n    verbose = false\n  } = {}) {\n    const reversedHistory = [];\n    const moveHistory = [];\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove());\n    }\n\n    while (true) {\n      const move = reversedHistory.pop();\n\n      if (!move) {\n        break;\n      }\n\n      if (verbose) {\n        moveHistory.push(Object.assign({\n          fen: this.fen()\n        }, this._makePretty(move)));\n      } else {\n        moveHistory.push(this._moveToSan(move, this._moves()));\n      }\n\n      this._makeMove(move);\n    }\n\n    return moveHistory;\n  }\n\n  _pruneComments() {\n    const reversedHistory = [];\n    const currentComments = {};\n\n    const copyComment = fen => {\n      if (fen in this._comments) {\n        currentComments[fen] = this._comments[fen];\n      }\n    };\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove());\n    }\n\n    copyComment(this.fen());\n\n    while (true) {\n      const move = reversedHistory.pop();\n\n      if (!move) {\n        break;\n      }\n\n      this._makeMove(move);\n\n      copyComment(this.fen());\n    }\n\n    this._comments = currentComments;\n  }\n\n  getComment() {\n    return this._comments[this.fen()];\n  }\n\n  setComment(comment) {\n    this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n  }\n\n  deleteComment() {\n    const comment = this._comments[this.fen()];\n\n    delete this._comments[this.fen()];\n    return comment;\n  }\n\n  getComments() {\n    this._pruneComments();\n\n    return Object.keys(this._comments).map(fen => {\n      return {\n        fen: fen,\n        comment: this._comments[fen]\n      };\n    });\n  }\n\n  deleteComments() {\n    this._pruneComments();\n\n    return Object.keys(this._comments).map(fen => {\n      const comment = this._comments[fen];\n      delete this._comments[fen];\n      return {\n        fen: fen,\n        comment: comment\n      };\n    });\n  }\n\n}\n\nexports.Chess = Chess;","map":null,"metadata":{},"sourceType":"script"}