{"ast":null,"code":"import * as i4 from '@angular/cdk/drag-drop';\nimport { DragDropModule } from '@angular/cdk/drag-drop';\nimport * as i3 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Injectable, Component, ViewChild, Input, EventEmitter, Output, HostListener, NgModule } from '@angular/core';\nimport { BehaviorSubject, Subject } from 'rxjs';\nimport { cloneDeep } from 'lodash';\nconst _c0 = [\"myModal\"];\n\nfunction PiecePromotionModalComponent_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 5)(1, \"div\", 6);\n    i0.ɵɵlistener(\"click\", function PiecePromotionModalComponent_div_4_Template_div_click_1_listener() {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r3 = i0.ɵɵnextContext();\n      return ctx_r3.changeSelection(1);\n    });\n    i0.ɵɵelement(2, \"img\", 7);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"div\", 6);\n    i0.ɵɵlistener(\"click\", function PiecePromotionModalComponent_div_4_Template_div_click_3_listener() {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return ctx_r5.changeSelection(2);\n    });\n    i0.ɵɵelement(4, \"img\", 8);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"div\", 6);\n    i0.ɵɵlistener(\"click\", function PiecePromotionModalComponent_div_4_Template_div_click_5_listener() {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.changeSelection(3);\n    });\n    i0.ɵɵelement(6, \"img\", 9);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(7, \"div\", 6);\n    i0.ɵɵlistener(\"click\", function PiecePromotionModalComponent_div_4_Template_div_click_7_listener() {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return ctx_r7.changeSelection(4);\n    });\n    i0.ɵɵelement(8, \"img\", 10);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"src\", ctx_r1.getPieceIcon(\"queen\"), i0.ɵɵsanitizeUrl);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"src\", ctx_r1.getPieceIcon(\"rook\"), i0.ɵɵsanitizeUrl);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"src\", ctx_r1.getPieceIcon(\"bishop\"), i0.ɵɵsanitizeUrl);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"src\", ctx_r1.getPieceIcon(\"knight\"), i0.ɵɵsanitizeUrl);\n  }\n}\n\nfunction PiecePromotionModalComponent_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 5)(1, \"div\", 6);\n    i0.ɵɵlistener(\"click\", function PiecePromotionModalComponent_div_5_Template_div_click_1_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return ctx_r8.changeSelection(1);\n    });\n    i0.ɵɵtext(2, \"\\u265B\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"div\", 6);\n    i0.ɵɵlistener(\"click\", function PiecePromotionModalComponent_div_5_Template_div_click_3_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return ctx_r10.changeSelection(2);\n    });\n    i0.ɵɵtext(4, \"\\u265C\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"div\", 6);\n    i0.ɵɵlistener(\"click\", function PiecePromotionModalComponent_div_5_Template_div_click_5_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.changeSelection(3);\n    });\n    i0.ɵɵtext(6, \"\\u265D\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(7, \"div\", 6);\n    i0.ɵɵlistener(\"click\", function PiecePromotionModalComponent_div_5_Template_div_click_7_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r12 = i0.ɵɵnextContext();\n      return ctx_r12.changeSelection(4);\n    });\n    i0.ɵɵtext(8, \"\\u265E\");\n    i0.ɵɵelementEnd()();\n  }\n}\n\nconst _c1 = [\"boardRef\"];\nconst _c2 = [\"modal\"];\n\nfunction NgxChessBoardComponent_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 11);\n    i0.ɵɵlistener(\"cdkDragEnded\", function NgxChessBoardComponent_div_3_Template_div_cdkDragEnded_0_listener($event) {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r9 = i0.ɵɵnextContext();\n      return ctx_r9.dragEnded($event);\n    })(\"cdkDragMoved\", function NgxChessBoardComponent_div_3_Template_div_cdkDragMoved_0_listener($event) {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.dragMoved($event);\n    })(\"cdkDragStarted\", function NgxChessBoardComponent_div_3_Template_div_cdkDragStarted_0_listener($event) {\n      i0.ɵɵrestoreView(_r10);\n      const ctx_r12 = i0.ɵɵnextContext();\n      return ctx_r12.dragStart($event);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const piece_r7 = ctx.$implicit;\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"transform\", \"translate3d(\" + piece_r7.point.col * ctx_r1.pieceSize + \"px, \" + piece_r7.point.row * ctx_r1.pieceSize + \"px,0px)\")(\"max-height\", ctx_r1.pieceSize + \"px\")(\"font-size\", ctx_r1.pieceSize * 0.8 + \"px\")(\"width\", ctx_r1.pieceSize + \"px\")(\"height\", ctx_r1.pieceSize + \"px\");\n    i0.ɵɵproperty(\"cdkDragDisabled\", ctx_r1.engineFacade.dragDisabled)(\"innerHTML\", ctx_r1.engineFacade.pieceIconManager.isDefaultIcons() ? piece_r7.constant.icon : \"\", i0.ɵɵsanitizeHtml)(\"ngStyle\", ctx_r1.engineFacade.pieceIconManager.isDefaultIcons() ? \"\" : ctx_r1.getCustomPieceIcons(piece_r7));\n  }\n}\n\nfunction NgxChessBoardComponent_div_4_div_1_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 18);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const i_r14 = i0.ɵɵnextContext(2).index;\n    const ctx_r18 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"color\", i_r14 % 2 === 0 ? ctx_r18.lightTileColor : ctx_r18.darkTileColor)(\"font-size\", ctx_r18.pieceSize / 4, \"px\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r18.engineFacade.coords.yCoords[i_r14], \" \");\n  }\n}\n\nfunction NgxChessBoardComponent_div_4_div_1_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 19);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const j_r17 = i0.ɵɵnextContext().index;\n    const ctx_r19 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"color\", j_r17 % 2 === 0 ? ctx_r19.lightTileColor : ctx_r19.darkTileColor)(\"font-size\", ctx_r19.pieceSize / 4, \"px\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r19.engineFacade.coords.xCoords[j_r17], \" \");\n  }\n}\n\nfunction NgxChessBoardComponent_div_4_div_1_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 20);\n    i0.ɵɵelement(1, \"div\", 21);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r20 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"font-size\", ctx_r20.pieceSize + \"px\");\n    i0.ɵɵproperty(\"ngClass\", \"piece\");\n  }\n}\n\nfunction NgxChessBoardComponent_div_4_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 14);\n    i0.ɵɵtemplate(1, NgxChessBoardComponent_div_4_div_1_span_1_Template, 2, 5, \"span\", 15);\n    i0.ɵɵtemplate(2, NgxChessBoardComponent_div_4_div_1_span_2_Template, 2, 5, \"span\", 16);\n    i0.ɵɵtemplate(3, NgxChessBoardComponent_div_4_div_1_div_3_Template, 2, 3, \"div\", 17);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const j_r17 = ctx.index;\n    const i_r14 = i0.ɵɵnextContext().index;\n    const ctx_r15 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"background-color\", ctx_r15.getTileBackgroundColor(i_r14, j_r17));\n    i0.ɵɵclassProp(\"current-selection\", ctx_r15.showActivePiece && ctx_r15.engineFacade.board.isXYInActiveMove(i_r14, j_r17))(\"king-check\", ctx_r15.engineFacade.board.isKingChecked(ctx_r15.engineFacade.board.getPieceByPoint(i_r14, j_r17)))(\"point-circle\", ctx_r15.engineFacade.board.isXYInPointSelection(i_r14, j_r17))(\"possible-capture\", ctx_r15.showPossibleCaptures && ctx_r15.engineFacade.board.isXYInPossibleCaptures(i_r14, j_r17))(\"possible-point\", ctx_r15.engineFacade.board.isXYInPossibleMoves(i_r14, j_r17) && ctx_r15.showLegalMoves);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r15.showCoords && j_r17 === 7);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r15.showCoords && i_r14 === 7);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r15.engineFacade.board.getPieceByPoint(i_r14, j_r17));\n  }\n}\n\nfunction NgxChessBoardComponent_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 12);\n    i0.ɵɵtemplate(1, NgxChessBoardComponent_div_4_div_1_Template, 4, 15, \"div\", 13);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const row_r13 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", row_r13);\n  }\n}\n\nfunction NgxChessBoardComponent__svg_defs_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"defs\")(1, \"marker\", 22);\n    i0.ɵɵelement(2, \"path\", 23);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const color_r25 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"id\", color_r25 + \"Arrow\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"fill\", color_r25);\n  }\n}\n\nfunction NgxChessBoardComponent__svg_line_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"line\", 24);\n  }\n\n  if (rf & 2) {\n    const arrow_r26 = ctx.$implicit;\n    i0.ɵɵattribute(\"marker-end\", \"url(#\" + arrow_r26.end.color + \"Arrow)\")(\"stroke\", arrow_r26.end.color)(\"x1\", arrow_r26.start.x)(\"x2\", arrow_r26.end.x)(\"y1\", arrow_r26.start.y)(\"y2\", arrow_r26.end.y);\n  }\n}\n\nfunction NgxChessBoardComponent__svg_circle_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"circle\", 25);\n  }\n\n  if (rf & 2) {\n    const circle_r27 = ctx.$implicit;\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"cx\", circle_r27.drawPoint.x)(\"cy\", circle_r27.drawPoint.y)(\"r\", ctx_r5.engineFacade.heightAndWidth / 18)(\"stroke\", circle_r27.drawPoint.color);\n  }\n}\n\nconst _c3 = function () {\n  return [\"red\", \"green\", \"blue\", \"orange\"];\n};\n\nvar Color = /*#__PURE__*/(() => {\n  (function (Color) {\n    Color[Color[\"WHITE\"] = 0] = \"WHITE\";\n    Color[Color[\"BLACK\"] = 1] = \"BLACK\";\n  })(Color || (Color = {}));\n\n  return Color;\n})();\n\nclass Piece {\n  constructor(point, color, constant, relValue, board) {\n    this.checkPoints = [];\n    this.color = color;\n    this.constant = constant;\n    this.point = point;\n    this.relValue = relValue;\n    this.board = board;\n  }\n\n}\n\nclass Point {\n  constructor(row, col) {\n    this.row = row;\n    this.col = col;\n  }\n\n  isEqual(that) {\n    return that && this.row === that.row && this.col === that.col;\n  }\n\n  hasCoordsEqual(row, col) {\n    return row && col && this.row === row && this.col === col;\n  }\n\n  isInRange() {\n    return this.row >= 0 && this.row <= 7 && this.col >= 0 && this.col <= 7;\n  }\n\n  clone() {\n    return new Point(this.row, this.col);\n  }\n\n}\n\nclass Rook extends Piece {\n  constructor(point, color, constant, board) {\n    super(point, color, constant, 5, board);\n    this.isMovedAlready = false;\n  }\n\n  getPossibleMoves() {\n    const possiblePoints = [];\n    const row = this.point.row;\n    const col = this.point.col;\n\n    for (let i = row + 1; i < 8; ++i) {\n      // dol\n      if (this.board.isFieldEmpty(i, col)) {\n        possiblePoints.push(new Point(i, col));\n      } else {\n        break;\n      }\n    }\n\n    for (let i = row - 1; i >= 0; --i) {\n      // gora\n      if (this.board.isFieldEmpty(i, col)) {\n        possiblePoints.push(new Point(i, col));\n      } else {\n        break;\n      }\n    }\n\n    for (let j = col - 1; j >= 0; --j) {\n      // lewo\n      if (this.board.isFieldEmpty(row, j)) {\n        possiblePoints.push(new Point(row, j));\n      } else {\n        break;\n      }\n    }\n\n    for (let j = col + 1; j < 8; ++j) {\n      // prawo\n      if (this.board.isFieldEmpty(row, j)) {\n        possiblePoints.push(new Point(row, j));\n      } else {\n        break;\n      }\n    }\n\n    return possiblePoints;\n  }\n\n  getPossibleCaptures() {\n    const possiblePoints = [];\n    const row = this.point.row;\n    const col = this.point.col;\n\n    for (let i = row + 1; i < 8; ++i) {\n      // dol\n      if (this.board.isFieldTakenByEnemy(i, col, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(i, col));\n        break;\n      } else {\n        if (!this.board.isFieldEmpty(i, col)) {\n          break;\n        }\n      }\n    }\n\n    for (let i = row - 1; i >= 0; --i) {\n      // gora\n      if (this.board.isFieldTakenByEnemy(i, col, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(i, col));\n        break;\n      } else {\n        if (!this.board.isFieldEmpty(i, col)) {\n          break;\n        }\n      }\n    }\n\n    for (let j = col - 1; j >= 0; --j) {\n      // lewo\n      if (this.board.isFieldTakenByEnemy(row, j, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(row, j));\n        break;\n      } else {\n        if (!this.board.isFieldEmpty(row, j)) {\n          break;\n        }\n      }\n    }\n\n    for (let j = col + 1; j < 8; ++j) {\n      // prawo\n      if (this.board.isFieldTakenByEnemy(row, j, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(row, j));\n        break;\n      } else {\n        if (!this.board.isFieldEmpty(row, j)) {\n          break;\n        }\n      }\n    }\n\n    return possiblePoints;\n  }\n\n  getCoveredFields() {\n    const possiblePoints = [];\n    const row = this.point.row;\n    const col = this.point.col;\n\n    for (let i = row + 1; i < 8; ++i) {\n      // dol\n      if (this.board.isFieldEmpty(i, col)) {\n        possiblePoints.push(new Point(i, col));\n      } else {\n        if (!(this.board.getPieceByField instanceof King)) {\n          possiblePoints.push(new Point(i, col));\n          break;\n        }\n      }\n    }\n\n    for (let i = row - 1; i >= 0; --i) {\n      // gora\n      if (this.board.isFieldEmpty(i, col)) {\n        possiblePoints.push(new Point(i, col));\n      } else {\n        if (!(this.board.getPieceByField instanceof King)) {\n          possiblePoints.push(new Point(i, col));\n          break;\n        }\n      }\n    }\n\n    for (let j = col - 1; j >= 0; --j) {\n      // lewo\n      if (this.board.isFieldEmpty(row, j)) {\n        possiblePoints.push(new Point(row, j));\n      } else {\n        if (!(this.board.getPieceByField instanceof King)) {\n          possiblePoints.push(new Point(row, j));\n          break;\n        }\n      }\n    }\n\n    for (let j = col + 1; j < 8; ++j) {\n      // prawo\n      if (this.board.isFieldEmpty(row, j)) {\n        possiblePoints.push(new Point(row, j));\n      } else {\n        if (!(this.board.getPieceByField instanceof King)) {\n          possiblePoints.push(new Point(row, j));\n          break;\n        }\n      }\n    }\n\n    return possiblePoints;\n  }\n\n}\n\nclass King extends Piece {\n  constructor(point, color, constant, board) {\n    super(point, color, constant, 0, board);\n    this.castledAlready = false;\n    this.shortCastled = false;\n    this.longCastled = false;\n    this.isCastling = false;\n  }\n\n  getPossibleMoves() {\n    const possiblePoints = [];\n    const row = this.point.row;\n    const col = this.point.col; // lewo\n\n    if (this.board.isFieldEmpty(row, col - 1) && !this.board.isFieldUnderAttack(row, col - 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row, col - 1));\n    } // prawo\n\n\n    if (this.board.isFieldEmpty(row, col + 1) && !this.board.isFieldUnderAttack(row, col + 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row, col + 1));\n    } // dol\n\n\n    if (this.board.isFieldEmpty(row + 1, col) && !this.board.isFieldUnderAttack(row + 1, col, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row + 1, col));\n    } // gora\n\n\n    if (this.board.isFieldEmpty(row - 1, col) && !this.board.isFieldUnderAttack(row - 1, col, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row - 1, col));\n    } // lewo gora\n\n\n    if (this.board.isFieldEmpty(row - 1, col - 1) && !this.board.isFieldUnderAttack(row - 1, col - 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row - 1, col - 1));\n    } // prawo gora\n\n\n    if (this.board.isFieldEmpty(row - 1, col + 1) && !this.board.isFieldUnderAttack(row - 1, col + 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row - 1, col + 1));\n    } // lewo dol\n\n\n    if (this.board.isFieldEmpty(row + 1, col - 1) && !this.board.isFieldUnderAttack(row + 1, col - 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row + 1, col - 1));\n    } // prawo dol\n\n\n    if (this.board.isFieldEmpty(row + 1, col + 1) && !this.board.isFieldUnderAttack(row + 1, col + 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row + 1, col + 1));\n    }\n\n    if (!this.isMovedAlready) {\n      let longCastlePossible = true;\n\n      for (let i = col - 1; i > 0; --i) {\n        if (!this.board.isFieldEmpty(row, i) || this.board.isFieldUnderAttack(row, i, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n          longCastlePossible = false;\n          break;\n        }\n      }\n\n      if (longCastlePossible && !this.board.isKingInCheck(this.color, this.board.pieces) && this.board.getPieceByField(row, 0)) {\n        const leftRook = this.board.getPieceByField(row, 0);\n\n        if (leftRook instanceof Rook) {\n          if (!leftRook.isMovedAlready) {\n            possiblePoints.push(new Point(row, col - 2));\n          }\n        }\n      }\n\n      let shortCastlePossible = true;\n\n      for (let i = col + 1; i < 7; ++i) {\n        if (!this.board.isFieldEmpty(row, i) || this.board.isFieldUnderAttack(row, i, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n          shortCastlePossible = false;\n          break;\n        }\n      }\n\n      if (shortCastlePossible && !this.board.isKingInCheck(this.color, this.board.pieces) && this.board.getPieceByField(row, 7)) {\n        const rightRook = this.board.getPieceByField(row, 7);\n\n        if (rightRook instanceof Rook) {\n          if (!rightRook.isMovedAlready) {\n            possiblePoints.push(new Point(row, col + 2));\n          }\n        }\n      }\n    }\n\n    return possiblePoints;\n  }\n\n  getPossibleCaptures() {\n    const possiblePoints = [];\n    const row = this.point.row;\n    const col = this.point.col; // lewo\n\n    if (this.board.isFieldTakenByEnemy(row, col - 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE) && !this.board.isFieldUnderAttack(row, col - 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row, col - 1));\n    } // prawo\n\n\n    if (this.board.isFieldTakenByEnemy(row, col + 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE) && !this.board.isFieldUnderAttack(row, col + 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row, col + 1));\n    } // dol\n\n\n    if (this.board.isFieldTakenByEnemy(row + 1, col, this.color === Color.WHITE ? Color.BLACK : Color.WHITE) && !this.board.isFieldUnderAttack(row + 1, col, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row + 1, col));\n    } // gora\n\n\n    if (this.board.isFieldTakenByEnemy(row - 1, col, this.color === Color.WHITE ? Color.BLACK : Color.WHITE) && !this.board.isFieldUnderAttack(row - 1, col, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row - 1, col));\n    } // lewo gora\n\n\n    if (this.board.isFieldTakenByEnemy(row - 1, col - 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE) && !this.board.isFieldUnderAttack(row - 1, col - 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row - 1, col - 1));\n    } // prawo gora\n\n\n    if (this.board.isFieldTakenByEnemy(row - 1, col + 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE) && !this.board.isFieldUnderAttack(row - 1, col + 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row - 1, col + 1));\n    } // lewo dol\n\n\n    if (this.board.isFieldTakenByEnemy(row + 1, col - 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE) && !this.board.isFieldUnderAttack(row + 1, col - 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row + 1, col - 1));\n    } // prawo dol\n\n\n    if (this.board.isFieldTakenByEnemy(row + 1, col + 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE) && !this.board.isFieldUnderAttack(row + 1, col + 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row + 1, col + 1));\n    }\n\n    return possiblePoints;\n  }\n\n  getCoveredFields() {\n    const possiblePoints = [];\n    const row = this.point.row;\n    const col = this.point.col; // lewo\n\n    possiblePoints.push(new Point(row, col - 1)); // prawo\n\n    possiblePoints.push(new Point(row, col + 1)); // dol\n\n    possiblePoints.push(new Point(row + 1, col)); // gora\n\n    possiblePoints.push(new Point(row - 1, col)); // lewo gora\n\n    possiblePoints.push(new Point(row - 1, col - 1)); // prawo gora\n\n    possiblePoints.push(new Point(row - 1, col + 1)); // lewo dol\n\n    possiblePoints.push(new Point(row + 1, col - 1)); // prawo dol\n\n    possiblePoints.push(new Point(row + 1, col + 1));\n    return possiblePoints;\n  }\n\n}\n\nclass Bishop extends Piece {\n  constructor(point, color, constant, board) {\n    super(point, color, constant, 3, board);\n  }\n\n  getPossibleMoves() {\n    const possiblePoints = [];\n    const row = this.point.row;\n    const col = this.point.col;\n\n    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j) {\n      // lewa gorna przekatna\n      if (this.board.isFieldEmpty(i, j)) {\n        possiblePoints.push(new Point(i, j));\n      } else {\n        break;\n      }\n    }\n\n    for (let i = row - 1, j = col + 1; i >= 0 && j < 8; --i, ++j) {\n      // prawa gorna przekatna\n      if (this.board.isFieldEmpty(i, j)) {\n        possiblePoints.push(new Point(i, j));\n      } else {\n        break;\n      }\n    }\n\n    for (let i = row + 1, j = col - 1; i < 8 && j >= 0; ++i, --j) {\n      // lewa dolna przekatna\n      if (this.board.isFieldEmpty(i, j)) {\n        possiblePoints.push(new Point(i, j));\n      } else {\n        break;\n      }\n    }\n\n    for (let i = row + 1, j = col + 1; i < 8 && j < 8; ++i, ++j) {\n      // prawa dolna przekatna\n      if (this.board.isFieldEmpty(i, j)) {\n        possiblePoints.push(new Point(i, j));\n      } else {\n        break;\n      }\n    }\n\n    return possiblePoints;\n  }\n\n  getPossibleCaptures() {\n    const possiblePoints = [];\n    const row = this.point.row;\n    const col = this.point.col;\n\n    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j) {\n      // lewa gorna przekatna\n      if (this.board.isFieldTakenByEnemy(i, j, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(i, j));\n        break;\n      } else {\n        if (!this.board.isFieldEmpty(i, j)) {\n          break;\n        }\n      }\n    }\n\n    for (let i = row - 1, j = col + 1; i >= 0 && j < 8; --i, ++j) {\n      // prawa gorna przekatna\n      if (this.board.isFieldTakenByEnemy(i, j, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(i, j));\n        break;\n      } else {\n        if (!this.board.isFieldEmpty(i, j)) {\n          break;\n        }\n      }\n    }\n\n    for (let i = row + 1, j = col - 1; i < 8 && j >= 0; ++i, --j) {\n      // lewa dolna przekatna\n      if (this.board.isFieldTakenByEnemy(i, j, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(i, j));\n        break;\n      } else {\n        if (!this.board.isFieldEmpty(i, j)) {\n          break;\n        }\n      }\n    }\n\n    for (let i = row + 1, j = col + 1; i < 8 && j < 8; ++i, ++j) {\n      // prawa dolna przekatna\n      if (this.board.isFieldTakenByEnemy(i, j, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(i, j));\n        break;\n      } else {\n        if (!this.board.isFieldEmpty(i, j)) {\n          break;\n        }\n      }\n    }\n\n    return possiblePoints;\n  }\n\n  getCoveredFields() {\n    const possiblePoints = [];\n    const row = this.point.row;\n    const col = this.point.col;\n\n    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j) {\n      // lewa gorna przekatna\n      if (this.board.isFieldEmpty(i, j)) {\n        possiblePoints.push(new Point(i, j));\n      } else {\n        if (!(this.board.getPieceByField(i, j) instanceof King)) {\n          possiblePoints.push(new Point(i, j));\n        }\n\n        break;\n      }\n    }\n\n    for (let i = row - 1, j = col + 1; i >= 0 && j < 8; --i, ++j) {\n      // prawa gorna przekatna\n      if (this.board.isFieldEmpty(i, j)) {\n        possiblePoints.push(new Point(i, j));\n      } else {\n        if (!(this.board.getPieceByField(i, j) instanceof King)) {\n          possiblePoints.push(new Point(i, j));\n        }\n\n        break;\n      }\n    }\n\n    for (let i = row + 1, j = col - 1; i < 8 && j >= 0; ++i, --j) {\n      // lewa dolna przekatna\n      if (this.board.isFieldEmpty(i, j)) {\n        possiblePoints.push(new Point(i, j));\n      } else {\n        if (!(this.board.getPieceByField(i, j) instanceof King)) {\n          possiblePoints.push(new Point(i, j));\n        }\n\n        break;\n      }\n    }\n\n    for (let i = row + 1, j = col + 1; i < 8 && j < 8; ++i, ++j) {\n      // prawa dolna przekatna\n      if (this.board.isFieldEmpty(i, j)) {\n        possiblePoints.push(new Point(i, j));\n      } else {\n        if (!(this.board.getPieceByField(i, j) instanceof King)) {\n          possiblePoints.push(new Point(i, j));\n        }\n\n        break;\n      }\n    }\n\n    return possiblePoints;\n  }\n\n}\n\nclass Knight extends Piece {\n  constructor(point, color, constant, board) {\n    super(point, color, constant, 3, board);\n    this.isMovedAlready = false;\n  }\n\n  getPossibleMoves() {\n    const possiblePoints = [];\n    const row = this.point.row;\n    const col = this.point.col; // gora -> lewo\n\n    if (this.board.isFieldEmpty(row - 2, col - 1)) {\n      possiblePoints.push(new Point(row - 2, col - 1));\n    } // gora -> prawo\n\n\n    if (this.board.isFieldEmpty(row - 2, col + 1)) {\n      possiblePoints.push(new Point(row - 2, col + 1));\n    } // lewo -> gora\n\n\n    if (this.board.isFieldEmpty(row - 1, col - 2)) {\n      possiblePoints.push(new Point(row - 1, col - 2));\n    } // prawo -> gora\n\n\n    if (this.board.isFieldEmpty(row - 1, col + 2)) {\n      possiblePoints.push(new Point(row - 1, col + 2));\n    } // lewo -> dol\n\n\n    if (this.board.isFieldEmpty(row + 1, col - 2)) {\n      possiblePoints.push(new Point(row + 1, col - 2));\n    } // prawo -> dol\n\n\n    if (this.board.isFieldEmpty(row + 1, col + 2)) {\n      possiblePoints.push(new Point(row + 1, col + 2));\n    } // dol -> lewo\n\n\n    if (this.board.isFieldEmpty(row + 2, col - 1)) {\n      possiblePoints.push(new Point(row + 2, col - 1));\n    } // dol -> prawo\n\n\n    if (this.board.isFieldEmpty(row + 2, col + 1)) {\n      possiblePoints.push(new Point(row + 2, col + 1));\n    }\n\n    return possiblePoints;\n  }\n\n  getPossibleCaptures() {\n    const possiblePoints = [];\n    const row = this.point.row;\n    const col = this.point.col; // gora -> lewo\n\n    if (this.board.isFieldTakenByEnemy(row - 2, col - 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row - 2, col - 1));\n    } // gora -> prawo\n\n\n    if (this.board.isFieldTakenByEnemy(row - 2, col + 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row - 2, col + 1));\n    } // lewo -> gora\n\n\n    if (this.board.isFieldTakenByEnemy(row - 1, col - 2, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row - 1, col - 2));\n    } // prawo -> gora\n\n\n    if (this.board.isFieldTakenByEnemy(row - 1, col + 2, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row - 1, col + 2));\n    } // lewo -> dol\n\n\n    if (this.board.isFieldTakenByEnemy(row + 1, col - 2, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row + 1, col - 2));\n    } // prawo -> dol\n\n\n    if (this.board.isFieldTakenByEnemy(row + 1, col + 2, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row + 1, col + 2));\n    } // dol -> lewo\n\n\n    if (this.board.isFieldTakenByEnemy(row + 2, col - 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row + 2, col - 1));\n    } // dol -> prawo\n\n\n    if (this.board.isFieldTakenByEnemy(row + 2, col + 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      possiblePoints.push(new Point(row + 2, col + 1));\n    }\n\n    return possiblePoints;\n  }\n\n  getCoveredFields() {\n    const possiblePoints = [];\n    const row = this.point.row;\n    const col = this.point.col; // gora -> lewo\n\n    possiblePoints.push(new Point(row - 2, col - 1)); // gora -> prawo\n\n    possiblePoints.push(new Point(row - 2, col + 1)); // lewo -> gora\n\n    possiblePoints.push(new Point(row - 1, col - 2)); // prawo -> gora\n\n    possiblePoints.push(new Point(row - 1, col + 2)); // lewo -> dol\n\n    possiblePoints.push(new Point(row + 1, col - 2)); // prawo -> dol\n\n    possiblePoints.push(new Point(row + 1, col + 2)); // dol -> lewo\n\n    possiblePoints.push(new Point(row + 2, col - 1)); // dol -> prawo\n\n    possiblePoints.push(new Point(row + 2, col + 1));\n    return possiblePoints;\n  }\n\n}\n\nclass Pawn extends Piece {\n  constructor(point, color, constant, board) {\n    super(point, color, constant, 1, board);\n    this.isMovedAlready = false;\n  }\n\n  getPossibleMoves() {\n    const possiblePoints = [];\n    const row = this.point.row;\n    const col = this.point.col;\n\n    if (!this.board.reverted && this.color === Color.WHITE || this.board.reverted && this.color === Color.BLACK) {\n      if (this.board.isFieldEmpty(row - 1, col)) {\n        possiblePoints.push(new Point(row - 1, col));\n\n        if (!this.isMovedAlready && this.board.isFieldEmpty(row - 2, col)) {\n          possiblePoints.push(new Point(row - 2, col));\n        }\n      }\n    } else {\n      if (\n      /*!board.isFieldTakenByEnemy(row + 1, col, Color.WHITE) &&*/\n      this.board.isFieldEmpty(row + 1, col)) {\n        possiblePoints.push(new Point(row + 1, col));\n\n        if (!this.isMovedAlready && this.board.isFieldEmpty(row + 2, col)) {\n          possiblePoints.push(new Point(row + 2, col));\n        }\n      }\n    }\n\n    return possiblePoints;\n  }\n\n  getPossibleCaptures() {\n    const possiblePoints = [];\n    const row = this.point.row;\n    const col = this.point.col;\n\n    if (!this.board.reverted && this.color === Color.WHITE || this.board.reverted && this.color === Color.BLACK) {\n      if (this.board.isFieldTakenByEnemy(row - 1, col - 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(row - 1, col - 1));\n      }\n\n      if (this.board.isFieldTakenByEnemy(row - 1, col + 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(row - 1, col + 1));\n      }\n    } else {\n      if (this.board.isFieldTakenByEnemy(row + 1, col - 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(row + 1, col - 1));\n      }\n\n      if (this.board.isFieldTakenByEnemy(row + 1, col + 1, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(row + 1, col + 1));\n      }\n    }\n\n    if (this.board.enPassantPoint && this.board.enPassantPiece.color === (this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n      if (row === this.board.enPassantPiece.point.row && Math.abs(this.board.enPassantPiece.point.col - col) === 1) {\n        possiblePoints.push(this.board.enPassantPoint);\n      }\n    }\n\n    return possiblePoints;\n  }\n\n  getCoveredFields() {\n    const possiblePoints = [];\n    const row = this.point.row;\n    const col = this.point.col;\n\n    if (!this.board.reverted && this.color === Color.WHITE || this.board.reverted && this.color === Color.BLACK) {\n      possiblePoints.push(new Point(row - 1, col - 1));\n      possiblePoints.push(new Point(row - 1, col + 1));\n    } else {\n      possiblePoints.push(new Point(row + 1, col - 1));\n      possiblePoints.push(new Point(row + 1, col + 1));\n    }\n\n    return possiblePoints;\n  }\n\n}\n\nclass Queen extends Piece {\n  constructor(point, color, constant, board) {\n    super(point, color, constant, 9, board);\n  }\n\n  getPossibleMoves() {\n    const possiblePoints = [];\n    const row = this.point.row;\n    const col = this.point.col;\n\n    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j) {\n      // lewa gorna przekatna\n      if (this.board.isFieldEmpty(i, j)) {\n        possiblePoints.push(new Point(i, j));\n      } else {\n        break;\n      }\n    }\n\n    for (let i = row - 1, j = col + 1; i >= 0 && j < 8; --i, ++j) {\n      // prawa gorna przekatna\n      if (this.board.isFieldEmpty(i, j)) {\n        possiblePoints.push(new Point(i, j));\n      } else {\n        break;\n      }\n    }\n\n    for (let i = row + 1, j = col - 1; i < 8 && j >= 0; ++i, --j) {\n      // lewa dolna przekatna\n      if (this.board.isFieldEmpty(i, j)) {\n        possiblePoints.push(new Point(i, j));\n      } else {\n        break;\n      }\n    }\n\n    for (let i = row + 1, j = col + 1; i < 8 && j < 8; ++i, ++j) {\n      // prawa dolna przekatna\n      if (this.board.isFieldEmpty(i, j)) {\n        possiblePoints.push(new Point(i, j));\n      } else {\n        break;\n      }\n    }\n\n    for (let i = row + 1; i < 8; ++i) {\n      // dol\n      if (this.board.isFieldEmpty(i, col)) {\n        possiblePoints.push(new Point(i, col));\n      } else {\n        break;\n      }\n    }\n\n    for (let i = row - 1; i >= 0; --i) {\n      // gora\n      if (this.board.isFieldEmpty(i, col)) {\n        possiblePoints.push(new Point(i, col));\n      } else {\n        break;\n      }\n    }\n\n    for (let j = col - 1; j >= 0; --j) {\n      // lewo\n      if (this.board.isFieldEmpty(row, j)) {\n        possiblePoints.push(new Point(row, j));\n      } else {\n        break;\n      }\n    }\n\n    for (let j = col + 1; j < 8; ++j) {\n      // prawo\n      if (this.board.isFieldEmpty(row, j)) {\n        possiblePoints.push(new Point(row, j));\n      } else {\n        break;\n      }\n    }\n\n    return possiblePoints;\n  }\n\n  getPossibleCaptures() {\n    const possiblePoints = [];\n    const row = this.point.row;\n    const col = this.point.col;\n\n    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j) {\n      // lewa gorna przekatna\n      if (this.board.isFieldTakenByEnemy(i, j, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(i, j));\n        break;\n      } else {\n        if (!this.board.isFieldEmpty(i, j)) {\n          break;\n        }\n      }\n    }\n\n    for (let i = row - 1, j = col + 1; i >= 0 && j < 8; --i, ++j) {\n      // prawa gorna przekatna\n      if (this.board.isFieldTakenByEnemy(i, j, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(i, j));\n        break;\n      } else {\n        if (!this.board.isFieldEmpty(i, j)) {\n          break;\n        }\n      }\n    }\n\n    for (let i = row + 1, j = col - 1; i < 8 && j >= 0; ++i, --j) {\n      // lewa dolna przekatna\n      if (this.board.isFieldTakenByEnemy(i, j, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(i, j));\n        break;\n      } else {\n        if (!this.board.isFieldEmpty(i, j)) {\n          break;\n        }\n      }\n    }\n\n    for (let i = row + 1, j = col + 1; i < 8 && j < 8; ++i, ++j) {\n      // prawa dolna przekatna\n      if (this.board.isFieldTakenByEnemy(i, j, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(i, j));\n        break;\n      } else {\n        if (!this.board.isFieldEmpty(i, j)) {\n          break;\n        }\n      }\n    }\n\n    for (let i = row + 1; i < 8; ++i) {\n      // dol\n      if (this.board.isFieldTakenByEnemy(i, col, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(i, col));\n        break;\n      } else {\n        if (!this.board.isFieldEmpty(i, col)) {\n          break;\n        }\n      }\n    }\n\n    for (let i = row - 1; i >= 0; --i) {\n      // gora\n      if (this.board.isFieldTakenByEnemy(i, col, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(i, col));\n        break;\n      } else {\n        if (!this.board.isFieldEmpty(i, col)) {\n          break;\n        }\n      }\n    }\n\n    for (let j = col - 1; j >= 0; --j) {\n      // lewo\n      if (this.board.isFieldTakenByEnemy(row, j, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(row, j));\n        break;\n      } else {\n        if (!this.board.isFieldEmpty(row, j)) {\n          break;\n        }\n      }\n    }\n\n    for (let j = col + 1; j < 8; ++j) {\n      // prawo\n      if (this.board.isFieldTakenByEnemy(row, j, this.color === Color.WHITE ? Color.BLACK : Color.WHITE)) {\n        possiblePoints.push(new Point(row, j));\n        break;\n      } else {\n        if (!this.board.isFieldEmpty(row, j)) {\n          break;\n        }\n      }\n    }\n\n    return possiblePoints;\n  }\n\n  getCoveredFields() {\n    const possiblePoints = [];\n    const row = this.point.row;\n    const col = this.point.col;\n\n    for (let i = row + 1; i < 8; ++i) {\n      // dol\n      if (this.board.isFieldEmpty(i, col)) {\n        possiblePoints.push(new Point(i, col));\n      } else {\n        if (!(this.board.getPieceByField(i, col) instanceof King)) {\n          possiblePoints.push(new Point(i, col));\n        }\n\n        break;\n      }\n    }\n\n    for (let i = row - 1; i >= 0; --i) {\n      // gora\n      if (this.board.isFieldEmpty(i, col)) {\n        possiblePoints.push(new Point(i, col));\n      } else {\n        if (!(this.board.getPieceByField(i, col) instanceof King)) {\n          possiblePoints.push(new Point(i, col));\n        }\n\n        break;\n      }\n    }\n\n    for (let j = col - 1; j >= 0; --j) {\n      // lewo\n      if (this.board.isFieldEmpty(row, j)) {\n        possiblePoints.push(new Point(row, j));\n      } else {\n        if (!(this.board.getPieceByField(row, j) instanceof King)) {\n          possiblePoints.push(new Point(row, j));\n        }\n\n        break;\n      }\n    }\n\n    for (let j = col + 1; j < 8; ++j) {\n      // prawo\n      if (this.board.isFieldEmpty(row, j)) {\n        possiblePoints.push(new Point(row, j));\n      } else {\n        if (!(this.board.getPieceByField(row, j) instanceof King)) {\n          possiblePoints.push(new Point(row, j));\n        }\n\n        break;\n      }\n    }\n\n    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j) {\n      // lewa gorna przekatna\n      if (this.board.isFieldEmpty(i, j)) {\n        possiblePoints.push(new Point(i, j));\n      } else {\n        if (!(this.board.getPieceByField(i, j) instanceof King)) {\n          possiblePoints.push(new Point(i, j));\n        }\n\n        break;\n      }\n    }\n\n    for (let i = row - 1, j = col + 1; i >= 0 && j < 8; --i, ++j) {\n      // prawa gorna przekatna\n      if (this.board.isFieldEmpty(i, j)) {\n        possiblePoints.push(new Point(i, j));\n      } else {\n        if (!(this.board.getPieceByField(i, j) instanceof King)) {\n          possiblePoints.push(new Point(i, j));\n        }\n\n        break;\n      }\n    }\n\n    for (let i = row + 1, j = col - 1; i < 8 && j >= 0; ++i, --j) {\n      // lewa dolna przekatna\n      if (this.board.isFieldEmpty(i, j)) {\n        possiblePoints.push(new Point(i, j));\n      } else {\n        if (!(this.board.getPieceByField(i, j) instanceof King)) {\n          possiblePoints.push(new Point(i, j));\n        }\n\n        break;\n      }\n    }\n\n    for (let i = row + 1, j = col + 1; i < 8 && j < 8; ++i, ++j) {\n      // prawa dolna przekatna\n      if (this.board.isFieldEmpty(i, j)) {\n        possiblePoints.push(new Point(i, j));\n      } else {\n        if (!(this.board.getPieceByField(i, j) instanceof King)) {\n          possiblePoints.push(new Point(i, j));\n        }\n\n        break;\n      }\n    }\n\n    return possiblePoints;\n  }\n\n}\n\nconst UnicodeConstants = {\n  WHITE_KING: {\n    name: 'King',\n    icon: '&#x2654;'\n  },\n  WHITE_QUEEN: {\n    name: 'Queen',\n    icon: '&#x2655;'\n  },\n  WHITE_KNIGHT: {\n    name: 'Knight',\n    icon: '&#x2658'\n  },\n  WHITE_ROOK: {\n    name: 'Rook',\n    icon: '&#x2656'\n  },\n  WHITE_PAWN: {\n    name: 'Pawn',\n    icon: '&#x2659'\n  },\n  WHITE_BISHOP: {\n    name: 'Bishop',\n    icon: '&#x2657'\n  },\n  BLACK_KING: {\n    name: 'King',\n    icon: '&#x265A'\n  },\n  BLACK_QUEEN: {\n    name: 'Queen',\n    icon: '&#x265B'\n  },\n  BLACK_KNIGHT: {\n    name: 'Knight',\n    icon: '&#x265E'\n  },\n  BLACK_ROOK: {\n    name: 'Rook',\n    icon: '&#x265C'\n  },\n  BLACK_PAWN: {\n    name: 'Pawn',\n    icon: '&#x265F'\n  },\n  BLACK_BISHOP: {\n    name: 'Bishop',\n    icon: '&#x265D'\n  }\n};\n\nclass DefaultFenProcessor {\n  process(notation, engineFacade) {\n    let fen = notation;\n\n    if (notation) {\n      engineFacade.board.reverted = false;\n      engineFacade.board.pieces = [];\n      const split = fen.split('/');\n\n      for (let i = 0; i < 8; ++i) {\n        let pointer = 0;\n\n        for (let j = 0; j < split[i].split(' ')[0].length; ++j) {\n          const chunk = split[i].charAt(j);\n\n          if (chunk.match(/[0-9]/)) {\n            pointer += Number(chunk);\n          } else {\n            switch (chunk) {\n              case 'r':\n                engineFacade.board.pieces.push(new Rook(new Point(i, pointer), Color.BLACK, UnicodeConstants.BLACK_ROOK, engineFacade.board));\n                break;\n\n              case 'n':\n                engineFacade.board.pieces.push(new Knight(new Point(i, pointer), Color.BLACK, UnicodeConstants.BLACK_KNIGHT, engineFacade.board));\n                break;\n\n              case 'b':\n                engineFacade.board.pieces.push(new Bishop(new Point(i, pointer), Color.BLACK, UnicodeConstants.BLACK_BISHOP, engineFacade.board));\n                break;\n\n              case 'q':\n                engineFacade.board.pieces.push(new Queen(new Point(i, pointer), Color.BLACK, UnicodeConstants.BLACK_QUEEN, engineFacade.board));\n                break;\n\n              case 'k':\n                engineFacade.board.pieces.push(new King(new Point(i, pointer), Color.BLACK, UnicodeConstants.BLACK_KING, engineFacade.board));\n                break;\n\n              case 'p':\n                {\n                  const pawn = new Pawn(new Point(i, pointer), Color.BLACK, UnicodeConstants.BLACK_PAWN, engineFacade.board);\n\n                  if (pawn.color === Color.BLACK && pawn.point.row !== 1 || pawn.color === Color.WHITE && pawn.point.row !== 6) {\n                    pawn.isMovedAlready = true;\n                  }\n\n                  engineFacade.board.pieces.push(pawn);\n                  break;\n                }\n\n              case 'R':\n                engineFacade.board.pieces.push(new Rook(new Point(i, pointer), Color.WHITE, UnicodeConstants.WHITE_ROOK, engineFacade.board));\n                break;\n\n              case 'N':\n                engineFacade.board.pieces.push(new Knight(new Point(i, pointer), Color.WHITE, UnicodeConstants.WHITE_KNIGHT, engineFacade.board));\n                break;\n\n              case 'B':\n                engineFacade.board.pieces.push(new Bishop(new Point(i, pointer), Color.WHITE, UnicodeConstants.WHITE_BISHOP, engineFacade.board));\n                break;\n\n              case 'Q':\n                engineFacade.board.pieces.push(new Queen(new Point(i, pointer), Color.WHITE, UnicodeConstants.WHITE_QUEEN, engineFacade.board));\n                break;\n\n              case 'K':\n                engineFacade.board.pieces.push(new King(new Point(i, pointer), Color.WHITE, UnicodeConstants.WHITE_KING, engineFacade.board));\n                break;\n\n              case 'P':\n                {\n                  const pawn = new Pawn(new Point(i, pointer), Color.WHITE, UnicodeConstants.WHITE_PAWN, engineFacade.board);\n\n                  if (pawn.color === Color.BLACK && pawn.point.row !== 1 || pawn.color === Color.WHITE && pawn.point.row !== 6) {\n                    pawn.isMovedAlready = true;\n                  }\n\n                  engineFacade.board.pieces.push(pawn);\n                  break;\n                }\n            }\n\n            ++pointer;\n          }\n        }\n      }\n\n      this.setCurrentPlayer(engineFacade.board, fen);\n      this.setCastles(engineFacade.board, fen);\n      this.setEnPassant(fen);\n      this.setFullMoveCount(fen);\n      engineFacade.board.fen = fen;\n    } else {\n      throw Error('Incorrect FEN provided');\n    }\n  }\n\n  setCurrentPlayer(board, fen) {\n    if (fen) {\n      const split = fen.split(' ');\n      board.currentWhitePlayer = split[1] === 'w';\n    }\n  }\n\n  setCastles(board, fen) {\n    if (fen) {\n      const split = fen.split(' ');\n      const castleChunk = split[2];\n\n      if (!castleChunk.includes('K')) {\n        this.setRookAlreadyMoved(board, Color.WHITE, 7);\n      }\n\n      if (!castleChunk.includes('Q')) {\n        this.setRookAlreadyMoved(board, Color.WHITE, 0);\n      }\n\n      if (!castleChunk.includes('k')) {\n        this.setRookAlreadyMoved(board, Color.BLACK, 7);\n      }\n\n      if (!castleChunk.includes('q')) {\n        this.setRookAlreadyMoved(board, Color.BLACK, 0);\n      }\n    }\n  }\n\n  setFullMoveCount(fen) {}\n\n  setEnPassant(fen) {\n    if (fen) {\n      const split = fen.split(' ');\n      const enPassantPoint = split[3];\n\n      if (enPassantPoint === '-') {\n        return;\n      } // if()\n\n    }\n  }\n\n  setRookAlreadyMoved(board, color, col) {\n    const rook = board.pieces.find(piece => piece.color === color && piece instanceof Rook && piece.point.col === col);\n\n    if (rook) {\n      rook.isMovedAlready = true;\n    }\n  }\n\n}\n\nclass MoveTranslation {\n  constructor(xAxis, yAxis, reverted) {\n    this._xAxis = xAxis;\n    this._yAxis = yAxis;\n    this._reverted = reverted;\n  }\n\n  get xAxis() {\n    return this._xAxis;\n  }\n\n  set xAxis(value) {\n    this._xAxis = value;\n  }\n\n  get yAxis() {\n    return this._yAxis;\n  }\n\n  set yAxis(value) {\n    this._yAxis = value;\n  }\n\n  get reverted() {\n    return this._reverted;\n  }\n\n  set reverted(value) {\n    this._reverted = value;\n  }\n\n}\n\nclass MoveUtils {\n  static willMoveCauseCheck(currentColor, row, col, destRow, destCol, board) {\n    const srcPiece = board.getPieceByField(row, col);\n    const destPiece = board.getPieceByField(destRow, destCol);\n\n    if (srcPiece) {\n      srcPiece.point.row = destRow;\n      srcPiece.point.col = destCol;\n    }\n\n    if (destPiece) {\n      board.pieces = board.pieces.filter(piece => piece !== destPiece);\n    }\n\n    const isBound = board.isKingInCheck(currentColor, board.pieces);\n\n    if (srcPiece) {\n      srcPiece.point.col = col;\n      srcPiece.point.row = row;\n    }\n\n    if (destPiece) {\n      board.pieces.push(destPiece);\n    }\n\n    return isBound;\n  }\n\n  static format(sourcePoint, destPoint, reverted) {\n    if (reverted) {\n      const sourceX = 104 - sourcePoint.col;\n      const destX = 104 - destPoint.col;\n      return String.fromCharCode(sourceX) + (sourcePoint.row + 1) + String.fromCharCode(destX) + (destPoint.row + 1);\n    } else {\n      const incrementX = 97;\n      return String.fromCharCode(sourcePoint.col + incrementX) + (Math.abs(sourcePoint.row - 7) + 1) + String.fromCharCode(destPoint.col + incrementX) + (Math.abs(destPoint.row - 7) + 1);\n    }\n  }\n\n  static translateCoordsToIndex(coords, reverted) {\n    let xAxis;\n    let yAxis;\n\n    if (reverted) {\n      xAxis = 104 - coords.charCodeAt(0);\n      yAxis = +coords.charAt(1) - 1;\n    } else {\n      xAxis = coords.charCodeAt(0) - 97;\n      yAxis = Math.abs(+coords.charAt(1) - 8);\n    }\n\n    return new MoveTranslation(xAxis, yAxis, reverted);\n  }\n\n  static findPieceByPossibleMovesContaining(coords, board, color) {\n    let indexes = this.translateCoordsToIndex(coords, board.reverted);\n    let destPoint = new Point(indexes.yAxis, indexes.xAxis);\n    let foundPieces = [];\n\n    for (let piece of board.pieces.filter(piece => piece.color === color)) {\n      for (let point of piece.getPossibleMoves()) {\n        if (!MoveUtils.willMoveCauseCheck(piece.color, piece.point.row, piece.point.col, indexes.yAxis, indexes.xAxis, board) && point.isEqual(destPoint)) {\n          foundPieces.push(piece);\n        }\n      }\n    }\n\n    return foundPieces;\n  }\n\n  static findPieceByPossibleCapturesContaining(coords, board, color) {\n    let indexes = this.translateCoordsToIndex(coords, board.reverted);\n    let destPoint = new Point(indexes.yAxis, indexes.xAxis);\n    let foundPieces = [];\n\n    for (let piece of board.pieces.filter(piece => piece.color === color)) {\n      for (let point of piece.getPossibleCaptures()) {\n        if (!MoveUtils.willMoveCauseCheck(piece.color, piece.point.row, piece.point.col, indexes.yAxis, indexes.xAxis, board) && point.isEqual(destPoint)) {\n          foundPieces.push(piece);\n        }\n      }\n    }\n\n    return foundPieces;\n  }\n\n  static formatSingle(point, reverted) {\n    if (reverted) {\n      const sourceX = 104 - point.col;\n      return String.fromCharCode(sourceX) + (point.row + 1);\n    } else {\n      const incrementX = 97;\n      return String.fromCharCode(point.col + incrementX) + (Math.abs(point.row - 7) + 1);\n    }\n  }\n\n  static getFirstLetterPiece(piece) {\n    if (piece instanceof Pawn) {\n      return 'P';\n    } else {\n      if (piece instanceof Knight) {\n        return 'N';\n      } else {\n        if (piece instanceof Bishop) {\n          return 'B';\n        } else {\n          if (piece instanceof Rook) {\n            return 'R';\n          } else {\n            if (piece instanceof King) {\n              return 'K';\n            } else {\n              if (piece instanceof Queen) {\n                return 'Q';\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return '';\n  }\n\n  static reverse(board, row) {\n    return board.reverted ? row + 1 : Math.abs(row - 7) + 1;\n  }\n\n  static formatCol(board, col) {\n    return board.reverted ? String.fromCharCode(104 - col) : String.fromCharCode(97 + col);\n  }\n\n}\n\nclass DefaultPiecesLoader {\n  static loadDefaultPieces(board) {\n    board.pieces = []; // piony czarne\n\n    for (let i = 0; i < 8; ++i) {\n      board.pieces.push(new Pawn(new Point(1, i), Color.BLACK, UnicodeConstants.BLACK_PAWN, board));\n    }\n\n    board.pieces.push(new Rook(new Point(0, 0), Color.BLACK, UnicodeConstants.BLACK_ROOK, board));\n    board.pieces.push(new Knight(new Point(0, 1), Color.BLACK, UnicodeConstants.BLACK_KNIGHT, board));\n    board.pieces.push(new Bishop(new Point(0, 2), Color.BLACK, UnicodeConstants.BLACK_BISHOP, board));\n    board.pieces.push(new Queen(new Point(0, 3), Color.BLACK, UnicodeConstants.BLACK_QUEEN, board));\n    board.pieces.push(new King(new Point(0, 4), Color.BLACK, UnicodeConstants.BLACK_KING, board));\n    board.pieces.push(new Bishop(new Point(0, 5), Color.BLACK, UnicodeConstants.BLACK_BISHOP, board));\n    board.pieces.push(new Knight(new Point(0, 6), Color.BLACK, UnicodeConstants.BLACK_KNIGHT, board));\n    board.pieces.push(new Rook(new Point(0, 7), Color.BLACK, UnicodeConstants.BLACK_ROOK, board)); // piony biale\n\n    for (let i = 0; i < 8; ++i) {\n      board.pieces.push(new Pawn(new Point(6, i), Color.WHITE, UnicodeConstants.WHITE_PAWN, board));\n    }\n\n    board.pieces.push(new Rook(new Point(7, 0), Color.WHITE, UnicodeConstants.WHITE_ROOK, board));\n    board.pieces.push(new Knight(new Point(7, 1), Color.WHITE, UnicodeConstants.WHITE_KNIGHT, board));\n    board.pieces.push(new Bishop(new Point(7, 2), Color.WHITE, UnicodeConstants.WHITE_BISHOP, board));\n    board.pieces.push(new Queen(new Point(7, 3), Color.WHITE, UnicodeConstants.WHITE_QUEEN, board));\n    board.pieces.push(new King(new Point(7, 4), Color.WHITE, UnicodeConstants.WHITE_KING, board));\n    board.pieces.push(new Bishop(new Point(7, 5), Color.WHITE, UnicodeConstants.WHITE_BISHOP, board));\n    board.pieces.push(new Knight(new Point(7, 6), Color.WHITE, UnicodeConstants.WHITE_KNIGHT, board));\n    board.pieces.push(new Rook(new Point(7, 7), Color.WHITE, UnicodeConstants.WHITE_ROOK, board));\n    board.calculateFEN();\n  }\n\n}\n\nclass DefaultPgnProcessor$1 {\n  process(notation, engineFacade) {\n    if (notation) {\n      engineFacade.board.reverted = false;\n      engineFacade.board.pieces = [];\n      engineFacade.reset();\n      DefaultPiecesLoader.loadDefaultPieces(engineFacade.board);\n      let moves = this.extractMoves(notation);\n      let counter = -1;\n\n      for (let move of moves) {\n        ++counter;\n        move = move.replace(/[+#]/g, '');\n        let promotionIndex = '';\n\n        if (move.includes('=')) {\n          promotionIndex = this.resolvePromotion(move.substring(move.length - 1));\n          move = move.substring(0, move.length - 2);\n        }\n\n        let color = counter === 0 || counter % 2 === 0 ? Color.WHITE : Color.BLACK;\n\n        if (/^[a-z]\\d$/g.test(move)) {\n          // zwykly ruch na wolne pole e4\n          let piece = MoveUtils.findPieceByPossibleMovesContaining(move, engineFacade.board, color).find(piece => piece instanceof Pawn); // en passant check\n\n          if (!piece) {\n            piece = MoveUtils.findPieceByPossibleCapturesContaining(move, engineFacade.board, color).find(piece => piece instanceof Pawn);\n          } // if piece is found for sure\n\n\n          if (piece) {\n            engineFacade.move(MoveUtils.formatSingle(piece.point, false) + move + promotionIndex);\n          }\n        } else {\n          if (/^[A-Z][a-h]\\d$/g.test(move)) {\n            // jezeli ma wielka litere, czyli trzeba odszukac ktora figura Nf3\n            let pieces = MoveUtils.findPieceByPossibleMovesContaining(move.substring(1), engineFacade.board, color);\n            let piece = pieces.find(piece => this.resolvePieceByFirstChar(move.charAt(0), piece));\n\n            if (piece) {\n              engineFacade.move(MoveUtils.formatSingle(piece.point, false) + move.substring(1) + promotionIndex);\n            } else {}\n          } else {\n            if ('O-O' === move) {\n              engineFacade.move(color === Color.WHITE ? 'e1g1' : 'e8g8');\n            } else {\n              if (/^[a-z]x[a-z]\\d$/g.test(move)) {\n                //exd5\n                let pieces = MoveUtils.findPieceByPossibleCapturesContaining(move.substring(move.indexOf('x') + 1), engineFacade.board, color).filter(piece => piece instanceof Pawn);\n                let piece;\n\n                if (pieces.length > 1) {\n                  piece = this.resolveByCol(pieces, move.substring(0, 1));\n                } else {\n                  piece = pieces[0];\n                }\n\n                if (piece) {\n                  engineFacade.move(MoveUtils.formatSingle(piece.point, false) + move.substring(move.indexOf('x') + 1) + promotionIndex);\n                } else {}\n              } else {\n                if (/^[A-Z]x[a-z]\\d$/g.test(move)) {\n                  let piece = MoveUtils.findPieceByPossibleCapturesContaining(move.substring(move.indexOf('x') + 1), engineFacade.board, color).find(piece => this.resolvePieceByFirstChar(move.substring(0, 1), piece));\n\n                  if (piece) {\n                    engineFacade.move(MoveUtils.formatSingle(piece.point, false) + move.substring(move.indexOf('x') + 1) + promotionIndex);\n                  } else {}\n                } else {\n                  if (move === 'O-O-O') {\n                    engineFacade.move(color === Color.WHITE ? 'e1c1' : 'e8c8');\n                  } else {\n                    if (/^[A-Z]\\dx[a-z]\\d$/g.test(move)) {\n                      //Ngxe4 sytuacja 2 skoczkow pion bicie\n                      let pieces = MoveUtils.findPieceByPossibleCapturesContaining(move.substring(move.indexOf('x') + 1), engineFacade.board, color).filter(piece => this.resolvePieceByFirstChar(move.charAt(0), piece));\n                      let piece = this.resolveByRow(pieces, move.substring(1, 2));\n\n                      if (piece) {\n                        engineFacade.move(MoveUtils.formatSingle(piece.point, false) + move.substring(move.indexOf('x') + 1) + promotionIndex);\n                      }\n                    } else {\n                      if (/^[A-Z][a-z][a-z]\\d$/g.test(move)) {\n                        // dwie wieze bez bicia Rac1 pion\n                        let pieces = MoveUtils.findPieceByPossibleMovesContaining(move.substring(2, 4), engineFacade.board, color).filter(piece => this.resolvePieceByFirstChar(move.charAt(0), piece));\n                        let piece = this.resolveByCol(pieces, move.substring(1, 2));\n\n                        if (piece) {\n                          engineFacade.move(MoveUtils.formatSingle(piece.point, false) + move.substring(2, 4) + promotionIndex);\n                        }\n                      } else {\n                        if (/^[A-Z][a-z]x[a-z]\\d$/g.test(move)) {\n                          let pieces = MoveUtils.findPieceByPossibleCapturesContaining(move.substring(move.indexOf('x') + 1), engineFacade.board, color).filter(piece => this.resolvePieceByFirstChar(move.charAt(0), piece));\n                          let piece = this.resolveByCol(pieces, move.substring(1, 2));\n\n                          if (piece) {\n                            engineFacade.move(MoveUtils.formatSingle(piece.point, false) + move.substring(move.indexOf('x') + 1) + promotionIndex);\n                          }\n                        } else {\n                          this.processR1f2(move, engineFacade, color, promotionIndex);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  processR1f2(move, engineFacade, color, promotionIndex) {\n    if (/^[A-Z]\\d[a-z]\\d$/g.test(move)) {\n      // R1f2\n      let pieces = MoveUtils.findPieceByPossibleMovesContaining(move.substring(2, 4), engineFacade.board, color).filter(piece => this.resolvePieceByFirstChar(move.charAt(0), piece));\n      let piece = this.resolveByRow(pieces, move.substring(1, 2));\n\n      if (piece) {\n        engineFacade.move(MoveUtils.formatSingle(piece.point, false) + move.substring(2, 4) + promotionIndex);\n      }\n    }\n  }\n\n  extractMoves(notation) {\n    return notation.substring(notation.lastIndexOf(']') + 1).replace(/[0-9]+\\./g, '').replace(/\\s+/g, ' ').replace(/{[^}]*}/g, '').trim().split(' ').filter(s => s);\n  }\n\n  movePiece(piece, board, move) {\n    let indexes = MoveUtils.translateCoordsToIndex(move, board.reverted);\n    piece.point.col = indexes.xAxis;\n    piece.point.row = indexes.yAxis;\n  }\n\n  hasUpperCase(move) {\n    return /[A-Z]/.test(move);\n  }\n\n  resolvePieceByFirstChar(move, piece) {\n    let piecesFirstChar = '';\n\n    if (piece instanceof King) {\n      piecesFirstChar = 'K';\n    } else {\n      if (piece instanceof Queen) {\n        piecesFirstChar = 'Q';\n      } else {\n        if (piece instanceof Rook) {\n          piecesFirstChar = 'R';\n        } else {\n          if (piece instanceof Bishop) {\n            piecesFirstChar = 'B';\n          } else {\n            if (piece instanceof Knight) {\n              piecesFirstChar = 'N';\n            } else {\n              if (piece instanceof Pawn) {\n                piecesFirstChar = 'P';\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return move === piecesFirstChar;\n  }\n\n  isShortCastle(move) {\n    return move === 'O-O';\n  }\n\n  removePiece(coords, board) {\n    let indexes = MoveUtils.translateCoordsToIndex(coords, board.reverted);\n    board.pieces = board.pieces.filter(e => !e.point.isEqual(new Point(indexes.yAxis, indexes.xAxis)));\n  }\n\n  isLongCastle(move) {\n    return move === 'O-O-O';\n  }\n\n  resolveByCol(pieces, char) {\n    let firstPieceFormat = MoveUtils.formatSingle(pieces[0].point, false);\n    let secondPieceFormat = MoveUtils.formatSingle(pieces[1].point, false);\n    return firstPieceFormat.substring(0, 1) === char ? pieces[0] : pieces[1];\n  }\n\n  resolveByRow(pieces, char) {\n    let firstPieceFormat = MoveUtils.formatSingle(pieces[0].point, false);\n    let secondPieceFormat = MoveUtils.formatSingle(pieces[1].point, false);\n    return firstPieceFormat.substring(1, 2) === char ? pieces[0] : pieces[1];\n  }\n\n  replacePromotion(move) {\n    return move.replace('=Q', '1').replace('=R', '2').replace('=B', '3').replace('=K', '4');\n  }\n\n  resolvePromotion(promotionChar) {\n    switch (promotionChar) {\n      case 'Q':\n        return '1';\n\n      case 'R':\n        return '2';\n\n      case 'B':\n        return '3';\n\n      case 'N':\n        return '4';\n    }\n\n    return '';\n  }\n\n}\n\nclass NotationProcessorFactory {\n  static getProcessor(type) {\n    switch (type) {\n      case NotationType.FEN:\n        return new DefaultFenProcessor();\n\n      case NotationType.PGN:\n        return new DefaultPgnProcessor$1();\n    }\n  }\n\n  static getDefaultProcessor() {\n    return new DefaultFenProcessor();\n  }\n\n}\n\nvar NotationType = /*#__PURE__*/(() => {\n  (function (NotationType) {\n    NotationType[NotationType[\"FEN\"] = 1] = \"FEN\";\n    NotationType[NotationType[\"PGN\"] = 2] = \"PGN\";\n  })(NotationType || (NotationType = {}));\n\n  return NotationType;\n})();\n\nclass DrawPoint {\n  constructor(x, y, color) {\n    this.x = x + 0.5;\n    this.y = y + 0.5;\n    this.color = color;\n  }\n\n  isEqual(that) {\n    return that && that.x === this.x && this.y === that.y;\n  }\n\n}\n\nclass ClickUtils {\n  static getClickPoint(event, top, height, left, width) {\n    return new Point(Math.floor((event.y - top) / (height / 8)), Math.floor((event.x - left) / (width / 8)));\n  }\n\n  static getDrawingPoint(tileSize, colorStrategy, x, y, ctrl, alt, shift, xAxis, yAxis) {\n    const squareSize = tileSize / 8;\n    const xx = Math.floor((x - xAxis) / squareSize);\n    const yy = Math.floor((y - yAxis) / squareSize);\n    let color = colorStrategy.resolve(ctrl, shift, alt);\n    return new DrawPoint(Math.floor(xx * squareSize + squareSize / 2), Math.floor(yy * squareSize + squareSize / 2), color);\n  }\n\n}\n\nclass HistoryMove {\n  constructor(move, piece, color, captured) {\n    this.move = move;\n    this.piece = piece;\n    this.color = color;\n    this.x = captured;\n  }\n\n  setGameStates(check, stalemate, mate) {\n    this.check = check;\n    this.stalemate = stalemate;\n    this.mate = mate;\n  }\n\n}\n\nclass HistoryMoveProvider {\n  constructor() {\n    this.historyMovesSubject$ = new BehaviorSubject([]);\n  }\n\n  get historyMoves() {\n    return this.historyMovesSubject$.value;\n  }\n\n  set historyMoves(states) {\n    this.historyMovesSubject$.next(states);\n  }\n\n  addMove(historyMove) {\n    this.historyMoves = [...this.historyMoves, historyMove];\n  }\n\n  pop() {\n    const lastHistoryMove = this.getLastMove();\n    this.historyMoves = this.historyMoves.filter(state => state !== lastHistoryMove);\n    return lastHistoryMove;\n  }\n\n  getAll() {\n    return this.historyMoves;\n  }\n\n  clear() {\n    this.historyMoves = [];\n  }\n\n  getLastMove() {\n    return this.historyMoves[this.getLastMoveIndex()];\n  }\n\n  getLastMoveIndex() {\n    return this.historyMoves.length - 1;\n  }\n\n}\n\nlet Constants = /*#__PURE__*/(() => {\n  class Constants {}\n\n  Constants.DEFAULT_DARK_TILE_COLOR = 'rgb(97, 84, 61)';\n  Constants.DEFAULT_LIGHT_TILE_COLOR = '#BAA378';\n  Constants.DEFAULT_SIZE = 500;\n  Constants.MIN_BOARD_SIZE = 100;\n  Constants.MAX_BOARD_SIZE = 4000;\n  Constants.DEFAULT_SOURCE_POINT_COLOR = 'rgba(146, 111, 26, 0.79)';\n  Constants.DEFAULT_DESTINATION_POINT_COLOR = '#b28e1a';\n  Constants.DEFAULT_LEGAL_MOVE_POINT_COLOR = 'radial-gradient(#13262F 15%, transparent 20%);';\n  return Constants;\n})();\n\nclass PieceIconInputManager {\n  constructor() {\n    this._defaultIcons = false;\n  }\n\n  get pieceIconInput() {\n    return this._pieceIconInput;\n  }\n\n  set pieceIconInput(value) {\n    this._pieceIconInput = value;\n  }\n\n  get defaultIcons() {\n    return this._defaultIcons;\n  }\n\n  set defaultIcons(value) {\n    this._defaultIcons = value;\n  }\n\n  isDefaultIcons() {\n    return this.pieceIconInput === undefined || this.pieceIconInput === null;\n  }\n\n  getPieceIcon(piece) {\n    let isWhite = piece.color === Color.WHITE;\n\n    switch (piece.constructor) {\n      case King:\n        return isWhite ? this.pieceIconInput.whiteKingUrl : this.pieceIconInput.blackKingUrl;\n\n      case Queen:\n        return isWhite ? this.pieceIconInput.whiteQueenUrl : this.pieceIconInput.blackQueenUrl;\n\n      case Rook:\n        return isWhite ? this.pieceIconInput.whiteRookUrl : this.pieceIconInput.blackRookUrl;\n\n      case Bishop:\n        return isWhite ? this.pieceIconInput.whiteBishopUrl : this.pieceIconInput.blackBishopUrl;\n\n      case Knight:\n        return isWhite ? this.pieceIconInput.whiteKnightUrl : this.pieceIconInput.blackKnightUrl;\n\n      case Pawn:\n        return isWhite ? this.pieceIconInput.whitePawnUrl : this.pieceIconInput.blackPawnUrl;\n    }\n  }\n\n  loadDefaultData() {\n    this.pieceIconInput = {\n      blackBishopUrl: '',\n      blackKingUrl: '',\n      blackKnightUrl: '',\n      blackQueenUrl: '',\n      blackRookUrl: '',\n      whiteBishopUrl: '',\n      whiteKingUrl: '',\n      whiteKnightUrl: '',\n      whitePawnUrl: '',\n      whiteQueenUrl: '',\n      whiteRookUrl: '',\n      blackPawnUrl: 'a'\n    };\n  }\n\n}\n\nclass CoordsProvider {\n  constructor() {\n    this.defaultXCoords = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\n    this.defaultYCoords = [8, 7, 6, 5, 4, 3, 2, 1];\n    this.currentXCoords = [...this.defaultXCoords];\n    this.currentYCoords = [...this.defaultYCoords];\n  }\n\n  get xCoords() {\n    return this.currentXCoords;\n  }\n\n  get yCoords() {\n    return this.currentYCoords;\n  }\n\n  reverse() {\n    this.currentXCoords = this.currentXCoords.reverse();\n    this.currentYCoords = this.currentYCoords.reverse();\n  }\n\n  reset() {\n    this.init();\n  }\n\n  init() {\n    this.currentXCoords = [...this.defaultXCoords];\n    this.currentYCoords = [...this.defaultYCoords];\n  }\n\n}\n\nclass AnimationDragEndProcessor {\n  dragEnded(event, disabling, startTrans) {\n    if (!disabling) {\n      if (startTrans) {\n        event.source._dragRef.getRootElement().style.transform = startTrans;\n      }\n    }\n  }\n\n}\n\nclass DragEndStrategy {\n  constructor() {\n    this.dragEndProcessor = new AnimationDragEndProcessor();\n  }\n\n  process(event, disabling, startTrans) {\n    this.dragEndProcessor.dragEnded(event, disabling, startTrans);\n  }\n\n  setDragEndProcessor(processor) {\n    this.dragEndProcessor = processor;\n  }\n\n}\n\nclass AnimationDragStartProcessor {\n  dragStarted(event) {\n    const style = event.source.getRootElement().style;\n    style.zIndex = '1000';\n    style.position = 'absolute';\n  }\n\n}\n\nclass DragStartStrategy {\n  constructor() {\n    this.dragStartProcessor = new AnimationDragStartProcessor();\n  }\n\n  process(event) {\n    this.dragStartProcessor.dragStarted(event);\n  }\n\n  setDragStartProcessor(processor) {\n    this.dragStartProcessor = processor;\n  }\n\n}\n\nclass DefaultColorProcessor {\n  resolve(ctrl, shift, alt) {\n    let color = 'green';\n\n    if (ctrl || shift) {\n      color = 'red';\n    }\n\n    if (alt) {\n      color = 'blue';\n    }\n\n    if ((shift || ctrl) && alt) {\n      color = 'orange';\n    }\n\n    return color;\n  }\n\n}\n\nclass ColorStrategy {\n  constructor() {\n    this.colorProcessor = new DefaultColorProcessor();\n  }\n\n  resolve(ctrl, shift, alt) {\n    return this.colorProcessor.resolve(ctrl, shift, alt);\n  }\n\n  setColorProcessor(colorProcessor) {\n    this.colorProcessor = colorProcessor;\n  }\n\n}\n\nclass DrawProvider {\n  constructor() {\n    this.arrowsSubject$ = new BehaviorSubject([]);\n    this.circlesSubject$ = new BehaviorSubject([]);\n    this.arrows$ = this.arrowsSubject$.asObservable();\n    this.circles$ = this.circlesSubject$.asObservable();\n  }\n\n  get circles() {\n    return this.circlesSubject$.value;\n  }\n\n  set circles(circles) {\n    this.circlesSubject$.next(circles);\n  }\n\n  get arrows() {\n    return this.arrowsSubject$.value;\n  }\n\n  set arrows(arrows) {\n    this.arrowsSubject$.next(arrows);\n  }\n\n  addCircle(circle) {\n    this.circles = [...this.circles, circle];\n  }\n\n  reomveCircle(removeCircle) {\n    this.circles = this.circles.filter(circle => !circle.isEqual(removeCircle));\n  }\n\n  addArrow(arrow) {\n    this.arrows = [...this.arrows, arrow];\n  }\n\n  removeArrow(removeArrow) {\n    this.arrows = this.arrows.filter(arrow => !arrow.isEqual(removeArrow));\n  }\n\n  containsCircle(checkCircle) {\n    return this.circles.some(circle => circle.isEqual(checkCircle));\n  }\n\n  containsArrow(checkArrow) {\n    return this.arrows.some(arrow => arrow.isEqual(checkArrow));\n  }\n\n  clear() {\n    this.arrows = [];\n    this.circles = [];\n  }\n\n}\n\nclass AbstractPgnProcessor {\n  constructor() {\n    this.pgn = '';\n    this.currentIndex = 0.5;\n  }\n\n  getPGN() {\n    return this.pgn;\n  }\n\n  processChecks(checkmate, check, stalemate) {\n    if (checkmate) {\n      this.pgn += '#';\n    } else {\n      if (check) {\n        this.pgn += '+';\n      }\n    }\n  }\n\n  reset() {\n    this.pgn = '';\n    this.currentIndex = 0.5;\n  }\n\n  addPromotionChoice(promotion) {\n    switch (promotion) {\n      case 1:\n        this.pgn += '=Q';\n        break;\n\n      case 2:\n        this.pgn += '=R';\n        break;\n\n      case 3:\n        this.pgn += '=B';\n        break;\n\n      case 4:\n        this.pgn += '=N';\n        break;\n    }\n  }\n\n  removeLast() {\n    if (this.currentIndex >= 0.5) {\n      this.currentIndex -= 0.5;\n      const regex1 = new RegExp(/\\d+\\./g);\n      regex1.test(this.pgn);\n      this.pgn = this.pgn.substring(0, regex1.lastIndex).trim();\n    }\n  }\n\n}\n\nclass DefaultPgnProcessor extends AbstractPgnProcessor {\n  process(board, sourcePiece, destPoint, destPiece) {\n    this.currentIndex += 0.5;\n    this.pgn += this.currentIndex % Math.floor(this.currentIndex) === 0 ? ' ' + this.currentIndex + '. ' : ' ';\n    let possibleCaptures = [];\n    let possibleMoves = [];\n\n    if (destPiece) {\n      possibleCaptures = MoveUtils.findPieceByPossibleCapturesContaining(MoveUtils.formatSingle(destPoint, board.reverted), board, sourcePiece.color).filter(piece => piece.constructor.name === sourcePiece.constructor.name);\n    }\n\n    possibleMoves = MoveUtils.findPieceByPossibleMovesContaining(MoveUtils.formatSingle(destPoint, board.reverted), board, sourcePiece.color).filter(piece => piece.constructor.name === sourcePiece.constructor.name);\n\n    if (sourcePiece instanceof Pawn && !destPiece && possibleCaptures.length === 0) {\n      this.pgn += MoveUtils.formatSingle(destPoint, board.reverted);\n    } else {\n      if (sourcePiece instanceof Pawn && destPiece) {\n        this.pgn += MoveUtils.formatSingle(sourcePiece.point, board.reverted).substring(0, 1) + 'x' + MoveUtils.formatSingle(destPoint, board.reverted);\n      } else {\n        if (sourcePiece instanceof King && Math.abs(sourcePiece.point.col - destPoint.col) === 2) {\n          if (board.reverted) {\n            this.pgn += destPoint.col < 2 ? 'O-O' : 'O-O-O';\n          } else {\n            this.pgn += destPoint.col < 3 ? 'O-O-O' : 'O-O';\n          }\n        } else {\n          if (!(sourcePiece instanceof Pawn) && possibleCaptures.length === 0 && possibleMoves.length < 2) {\n            // Nf3\n            this.pgn += MoveUtils.getFirstLetterPiece(sourcePiece) + MoveUtils.formatSingle(destPoint, board.reverted);\n          } else {\n            if (possibleMoves && possibleMoves.length === 2 && possibleCaptures.length === 0) {\n              // Nbd7\n              if (this.isEqualByCol(possibleMoves[0], possibleMoves[1])) {\n                this.pgn += MoveUtils.getFirstLetterPiece(sourcePiece) + MoveUtils.reverse(board, sourcePiece.point.row) + MoveUtils.formatSingle(destPoint, board.reverted);\n              } else {\n                this.pgn += MoveUtils.getFirstLetterPiece(sourcePiece) + MoveUtils.formatCol(board, sourcePiece.point.col) + MoveUtils.formatSingle(destPoint, board.reverted);\n              }\n            } else {\n              if (possibleCaptures.length > 1) {\n                if (this.isEqualByCol(possibleCaptures[0], possibleCaptures[1])) {\n                  this.pgn += MoveUtils.getFirstLetterPiece(sourcePiece) + MoveUtils.reverse(board, sourcePiece.point.row) + 'x' + MoveUtils.formatSingle(destPoint, board.reverted);\n                } else {\n                  this.pgn += MoveUtils.getFirstLetterPiece(sourcePiece) + MoveUtils.formatCol(board, sourcePiece.point.col) + 'x' + MoveUtils.formatSingle(destPoint, board.reverted);\n                }\n              } else {\n                this.pgn += MoveUtils.getFirstLetterPiece(sourcePiece) + 'x' + MoveUtils.formatSingle(destPoint, board.reverted);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    this.pgn = this.pgn.trim();\n  }\n\n  resolvePieceByFirstChar(move, piece) {\n    return MoveUtils.getFirstLetterPiece(piece) === move;\n  }\n\n  isEqualByCol(aPiece, bPiece) {\n    return aPiece.point.col === bPiece.point.col;\n  }\n\n}\n\nclass AbstractEngineFacade {\n  constructor(board) {\n    this.dragStartStrategy = new DragStartStrategy();\n    this.dragEndStrategy = new DragEndStrategy();\n    this.pgnProcessor = new DefaultPgnProcessor();\n    this.colorStrategy = new ColorStrategy();\n    this.coords = new CoordsProvider();\n    this.heightAndWidth = Constants.DEFAULT_SIZE;\n    this.freeMode = false;\n    this.drawProvider = new DrawProvider();\n    this.pieceIconManager = new PieceIconInputManager();\n    this.moveHistoryProvider = new HistoryMoveProvider();\n    this.disabling = false;\n    this.board = board;\n  }\n\n  checkIfPawnFirstMove(piece) {\n    if (piece instanceof Pawn) {\n      piece.isMovedAlready = true;\n    }\n  }\n\n  checkIfRookMoved(piece) {\n    if (piece instanceof Rook) {\n      piece.isMovedAlready = true;\n    }\n  }\n\n  checkIfKingMoved(piece) {\n    if (piece instanceof King) {\n      piece.isMovedAlready = true;\n    }\n  }\n\n  getMoveHistory() {\n    return this.moveHistoryProvider.getAll();\n  }\n\n}\n\nclass BoardLoader {\n  constructor(engineFacade, notationProcessor) {\n    this.engineFacade = engineFacade;\n\n    if (notationProcessor) {\n      this.notationProcessor = notationProcessor;\n    } else {\n      this.notationProcessor = NotationProcessorFactory.getDefaultProcessor();\n    }\n  }\n\n  addPieces() {\n    DefaultPiecesLoader.loadDefaultPieces(this.engineFacade.board);\n  }\n\n  loadFEN(fen) {\n    this.notationProcessor.process(fen, this.engineFacade);\n  }\n\n  loadPGN(pgn) {\n    this.notationProcessor.process(pgn, this.engineFacade);\n  }\n\n  setEngineFacade(engineFacade) {\n    this.engineFacade = engineFacade;\n  }\n\n  setNotationProcessor(notationProcessor) {\n    this.notationProcessor = notationProcessor;\n  }\n\n}\n\nclass BoardState {\n  constructor(board) {\n    this.board = board;\n  }\n\n}\n\nclass BoardStateProvider {\n  constructor() {\n    this.statesSubject$ = new BehaviorSubject([]);\n  }\n\n  get states() {\n    return this.statesSubject$.value;\n  }\n\n  set states(states) {\n    this.statesSubject$.next(states);\n  }\n\n  addMove(state) {\n    this.states = [...this.states, state];\n  }\n\n  getStates() {\n    return this.states;\n  }\n\n  pop() {\n    const lastState = this.getLastState();\n    this.states = this.states.filter(state => state !== lastState);\n    return lastState;\n  }\n\n  isEmpty() {\n    return this.states.length === 0;\n  }\n\n  clear() {\n    this.states = [];\n  }\n\n  getLastState() {\n    return this.states[this.getLastStateIndex()];\n  }\n\n  getLastStateIndex() {\n    return this.states.length - 1;\n  }\n\n}\n\nclass Arrow {\n  isEqual(arrow) {\n    return arrow && this.start.isEqual(arrow.start) && this.end.isEqual(arrow.end);\n  }\n\n}\n\nclass Circle {\n  isEqual(circle) {\n    return circle && this.drawPoint.isEqual(circle.drawPoint);\n  }\n\n}\n\nclass PieceAbstractDecorator {\n  constructor(piece) {\n    this.piece = piece;\n  }\n\n}\n\nclass AvailableMoveDecorator extends PieceAbstractDecorator {\n  constructor(piece, pointClicked, color, board) {\n    super(piece);\n    this.pointClicked = pointClicked;\n    this.color = color;\n    this.board = board;\n  }\n\n  getPossibleCaptures() {\n    return this.piece.getPossibleCaptures().filter(point => !MoveUtils.willMoveCauseCheck(this.color, this.pointClicked.row, this.pointClicked.col, point.row, point.col, this.board));\n  }\n\n  getPossibleMoves() {\n    return this.piece.getPossibleMoves().filter(point => !MoveUtils.willMoveCauseCheck(this.color, this.pointClicked.row, this.pointClicked.col, point.row, point.col, this.board));\n  }\n\n}\n\nclass PiecePromotionResolver {\n  static resolvePromotionChoice(board, piece, index) {\n    const isWhite = piece.color === Color.WHITE;\n\n    switch (index) {\n      case 1:\n        board.pieces.push(new Queen(piece.point, piece.color, isWhite ? UnicodeConstants.WHITE_QUEEN : UnicodeConstants.BLACK_QUEEN, board));\n        break;\n\n      case 2:\n        board.pieces.push(new Rook(piece.point, piece.color, isWhite ? UnicodeConstants.WHITE_ROOK : UnicodeConstants.BLACK_ROOK, board));\n        break;\n\n      case 3:\n        board.pieces.push(new Bishop(piece.point, piece.color, isWhite ? UnicodeConstants.WHITE_BISHOP : UnicodeConstants.BLACK_BISHOP, board));\n        break;\n\n      case 4:\n        board.pieces.push(new Knight(piece.point, piece.color, isWhite ? UnicodeConstants.WHITE_KNIGHT : UnicodeConstants.BLACK_KNIGHT, board));\n        break;\n    }\n  }\n\n}\n\nvar PieceTypeInput = /*#__PURE__*/(() => {\n  (function (PieceTypeInput) {\n    PieceTypeInput[PieceTypeInput[\"KING\"] = 1] = \"KING\";\n    PieceTypeInput[PieceTypeInput[\"QUEEN\"] = 2] = \"QUEEN\";\n    PieceTypeInput[PieceTypeInput[\"BISHOP\"] = 3] = \"BISHOP\";\n    PieceTypeInput[PieceTypeInput[\"KNIGHT\"] = 4] = \"KNIGHT\";\n    PieceTypeInput[PieceTypeInput[\"ROOK\"] = 5] = \"ROOK\";\n    PieceTypeInput[PieceTypeInput[\"PAWN\"] = 6] = \"PAWN\";\n  })(PieceTypeInput || (PieceTypeInput = {}));\n\n  return PieceTypeInput;\n})();\nvar ColorInput = /*#__PURE__*/(() => {\n  (function (ColorInput) {\n    ColorInput[ColorInput[\"LIGHT\"] = 1] = \"LIGHT\";\n    ColorInput[ColorInput[\"DARK\"] = 2] = \"DARK\";\n  })(ColorInput || (ColorInput = {}));\n\n  return ColorInput;\n})();\n\nclass PieceFactory {\n  static create(indexes, pieceTypeInput, colorInput, board) {\n    let piece;\n    let color = colorInput === ColorInput.LIGHT ? Color.WHITE : Color.BLACK;\n\n    switch (pieceTypeInput) {\n      case PieceTypeInput.QUEEN:\n        piece = new Queen(new Point(indexes.yAxis, indexes.xAxis), color, color === Color.WHITE ? UnicodeConstants.WHITE_QUEEN : UnicodeConstants.BLACK_QUEEN, board);\n        break;\n\n      case PieceTypeInput.KING:\n        piece = new King(new Point(indexes.yAxis, indexes.xAxis), color, color === Color.WHITE ? UnicodeConstants.WHITE_KING : UnicodeConstants.BLACK_KING, board);\n        break;\n\n      case PieceTypeInput.KNIGHT:\n        piece = new Knight(new Point(indexes.yAxis, indexes.xAxis), color, color === Color.WHITE ? UnicodeConstants.WHITE_KNIGHT : UnicodeConstants.BLACK_KNIGHT, board);\n        break;\n\n      case PieceTypeInput.BISHOP:\n        piece = new Bishop(new Point(indexes.yAxis, indexes.xAxis), color, color === Color.WHITE ? UnicodeConstants.WHITE_BISHOP : UnicodeConstants.BLACK_BISHOP, board);\n        break;\n\n      case PieceTypeInput.ROOK:\n        piece = new Rook(new Point(indexes.yAxis, indexes.xAxis), color, color === Color.WHITE ? UnicodeConstants.WHITE_ROOK : UnicodeConstants.BLACK_ROOK, board);\n        break;\n\n      case PieceTypeInput.PAWN:\n        piece = new Pawn(new Point(indexes.yAxis, indexes.xAxis), color, color === Color.WHITE ? UnicodeConstants.WHITE_PAWN : UnicodeConstants.BLACK_PAWN, board);\n        break;\n    }\n\n    return piece;\n  }\n\n}\n\nclass EngineFacade extends AbstractEngineFacade {\n  constructor(board, moveChange) {\n    super(board);\n    this._selected = false;\n    this.moveChange = moveChange;\n    this.boardLoader = new BoardLoader(this);\n    this.boardLoader.addPieces();\n    this.boardStateProvider = new BoardStateProvider();\n  }\n\n  reset() {\n    this.boardStateProvider.clear();\n    this.moveHistoryProvider.clear();\n    this.boardLoader.addPieces();\n    this.board.reset();\n    this.coords.reset();\n    this.drawProvider.clear();\n    this.pgnProcessor.reset();\n  }\n\n  undo() {\n    if (!this.boardStateProvider.isEmpty()) {\n      const lastBoard = this.boardStateProvider.pop().board;\n\n      if (this.board.reverted) {\n        lastBoard.reverse();\n      }\n\n      this.board = lastBoard;\n      this.board.possibleCaptures = [];\n      this.board.possibleMoves = [];\n      this.board.activePiece = null;\n      this.moveHistoryProvider.pop();\n      this.board.calculateFEN();\n      this.pgnProcessor.removeLast();\n    }\n  }\n\n  saveMoveClone() {\n    const clone = this.board.clone();\n\n    if (this.board.reverted) {\n      clone.reverse();\n    }\n\n    this.moveStateProvider.addMove(new BoardState(clone));\n  }\n\n  move(coords) {\n    if (coords) {\n      const sourceIndexes = MoveUtils.translateCoordsToIndex(coords.substring(0, 2), this.board.reverted);\n      const destIndexes = MoveUtils.translateCoordsToIndex(coords.substring(2, 4), this.board.reverted);\n      const srcPiece = this.board.getPieceByPoint(sourceIndexes.yAxis, sourceIndexes.xAxis);\n\n      if (srcPiece) {\n        if (this.board.currentWhitePlayer && srcPiece.color === Color.BLACK || !this.board.currentWhitePlayer && srcPiece.color === Color.WHITE) {\n          return;\n        }\n\n        this.prepareActivePiece(srcPiece, srcPiece.point);\n\n        if (this.board.isPointInPossibleMoves(new Point(destIndexes.yAxis, destIndexes.xAxis)) || this.board.isPointInPossibleCaptures(new Point(destIndexes.yAxis, destIndexes.xAxis))) {\n          this.saveClone();\n          this.movePiece(srcPiece, new Point(destIndexes.yAxis, destIndexes.xAxis), coords.length === 5 ? +coords.substring(4, 5) : 0);\n          this.board.lastMoveSrc = new Point(sourceIndexes.yAxis, sourceIndexes.xAxis);\n          this.board.lastMoveDest = new Point(destIndexes.yAxis, destIndexes.xAxis);\n          this.disableSelection();\n        } else {\n          this.disableSelection();\n        }\n      }\n    }\n  }\n\n  prepareActivePiece(pieceClicked, pointClicked) {\n    this.board.activePiece = pieceClicked;\n    this._selected = true;\n    this.board.possibleCaptures = new AvailableMoveDecorator(pieceClicked, pointClicked, this.board.currentWhitePlayer ? Color.WHITE : Color.BLACK, this.board).getPossibleCaptures();\n    this.board.possibleMoves = new AvailableMoveDecorator(pieceClicked, pointClicked, this.board.currentWhitePlayer ? Color.WHITE : Color.BLACK, this.board).getPossibleMoves();\n  }\n\n  onPieceClicked(pieceClicked, pointClicked) {\n    if (this.board.currentWhitePlayer && pieceClicked.color === Color.BLACK || !this.board.currentWhitePlayer && pieceClicked.color === Color.WHITE) {\n      return;\n    }\n\n    this.prepareActivePiece(pieceClicked, pointClicked);\n  }\n\n  handleClickEvent(pointClicked, isMouseDown) {\n    let moving = false;\n\n    if ((this.board.isPointInPossibleMoves(pointClicked) || this.board.isPointInPossibleCaptures(pointClicked) || this.freeMode) && pointClicked.isInRange()) {\n      this.saveClone();\n      this.board.lastMoveSrc = new Point(this.board.activePiece.point.row, this.board.activePiece.point.col);\n      this.board.lastMoveDest = pointClicked.clone();\n      this.movePiece(this.board.activePiece, pointClicked);\n\n      if (!this.board.activePiece.point.isEqual(this.board.lastMoveSrc)) {\n        moving = true;\n      }\n    }\n\n    if (isMouseDown || moving) {\n      this.disableSelection();\n    }\n\n    this.disableSelection();\n    const pieceClicked = this.board.getPieceByPoint(pointClicked.row, pointClicked.col);\n\n    if (pieceClicked && !moving) {\n      this.onFreeMode(pieceClicked);\n      this.onPieceClicked(pieceClicked, pointClicked);\n    }\n  }\n\n  onMouseDown(event, pointClicked, left, top) {\n    this.moveDone = false;\n\n    if (event.button !== 0) {\n      this.drawPoint = ClickUtils.getDrawingPoint(this.heightAndWidth, this.colorStrategy, event.x, event.y, event.ctrlKey, event.altKey, event.shiftKey, left, top);\n      return;\n    }\n\n    this.drawProvider.clear();\n\n    if (this.board.activePiece && pointClicked.isEqual(this.board.activePiece.point)) {\n      this.disabling = true;\n      return;\n    }\n\n    const pieceClicked = this.board.getPieceByPoint(pointClicked.row, pointClicked.col);\n\n    if (this.freeMode) {\n      if (pieceClicked) {\n        if (event.ctrlKey) {\n          this.board.pieces = this.board.pieces.filter(e => e !== pieceClicked);\n          return;\n        }\n\n        this.board.currentWhitePlayer = pieceClicked.color === Color.WHITE;\n      }\n    }\n\n    if (this.isPieceDisabled(pieceClicked)) {\n      return;\n    }\n\n    if (this._selected) {\n      this.handleClickEvent(pointClicked, true);\n    } else {\n      if (pieceClicked) {\n        this.onFreeMode(pieceClicked);\n        this.onPieceClicked(pieceClicked, pointClicked);\n      }\n    }\n  }\n\n  onMouseUp(event, pointClicked, left, top) {\n    this.moveDone = false;\n\n    if (event.button !== 0 && !this.drawDisabled) {\n      this.addDrawPoint(event.x, event.y, event.ctrlKey, event.altKey, event.shiftKey, left, top);\n      return;\n    }\n\n    this.drawProvider.clear();\n\n    if (this.dragDisabled) {\n      return;\n    }\n\n    if (this.board.activePiece && pointClicked.isEqual(this.board.activePiece.point) && this.disabling) {\n      this.disableSelection();\n      this.disabling = false;\n      return;\n    }\n\n    const pieceClicked = this.board.getPieceByPoint(pointClicked.row, pointClicked.col);\n\n    if (this.isPieceDisabled(pieceClicked)) {\n      return;\n    }\n\n    if (this._selected) {\n      this.handleClickEvent(pointClicked, false); //   this.possibleMoves = activePiece.getPossibleMoves();\n    }\n  }\n\n  saveClone() {\n    const clone = this.board.clone();\n\n    if (this.board.reverted) {\n      clone.reverse();\n    }\n\n    this.boardStateProvider.addMove(new BoardState(clone));\n  }\n\n  movePiece(toMovePiece, newPoint, promotionIndex) {\n    const destPiece = this.board.pieces.find(piece => piece.point.col === newPoint.col && piece.point.row === newPoint.row);\n    this.pgnProcessor.process(this.board, toMovePiece, newPoint, destPiece);\n\n    if (destPiece && toMovePiece.color !== destPiece.color) {\n      this.board.pieces = this.board.pieces.filter(piece => piece !== destPiece);\n    } else {\n      if (destPiece && toMovePiece.color === destPiece.color) {\n        return;\n      }\n    }\n\n    this.historyMoveCandidate = new HistoryMove(MoveUtils.format(toMovePiece.point, newPoint, this.board.reverted), toMovePiece.constant.name, toMovePiece.color === Color.WHITE ? 'white' : 'black', !!destPiece);\n    this.moveHistoryProvider.addMove(this.historyMoveCandidate);\n\n    if (toMovePiece instanceof King) {\n      const squaresMoved = Math.abs(newPoint.col - toMovePiece.point.col);\n\n      if (squaresMoved > 1) {\n        if (newPoint.col < 3) {\n          const leftRook = this.board.getPieceByField(toMovePiece.point.row, 0);\n\n          if (!this.freeMode) {\n            leftRook.point.col = this.board.reverted ? 2 : 3;\n          }\n        } else {\n          const rightRook = this.board.getPieceByField(toMovePiece.point.row, 7);\n\n          if (!this.freeMode) {\n            rightRook.point.col = this.board.reverted ? 4 : 5;\n          }\n        }\n      }\n    }\n\n    if (toMovePiece instanceof Pawn) {\n      this.board.checkIfPawnTakesEnPassant(newPoint);\n      this.board.checkIfPawnEnpassanted(toMovePiece, newPoint);\n    } else {\n      this.board.enPassantPoint = null;\n      this.board.enPassantPiece = null;\n    }\n\n    toMovePiece.point = newPoint;\n    this.increaseFullMoveCount();\n    this.board.currentWhitePlayer = !this.board.currentWhitePlayer;\n\n    if (!this.checkForPawnPromote(toMovePiece, promotionIndex)) {\n      this.afterMoveActions();\n    }\n  }\n\n  checkForPawnPromote(toPromotePiece, promotionIndex) {\n    if (!(toPromotePiece instanceof Pawn)) {\n      return;\n    }\n\n    if (toPromotePiece.point.row === 0 || toPromotePiece.point.row === 7) {\n      this.board.pieces = this.board.pieces.filter(piece => piece !== toPromotePiece); // When we make move manually, we pass promotion index already, so we don't need\n      // to acquire it from promote dialog\n\n      if (!promotionIndex) {\n        this.openPromoteDialog(toPromotePiece);\n      } else {\n        PiecePromotionResolver.resolvePromotionChoice(this.board, toPromotePiece, promotionIndex);\n        this.afterMoveActions(promotionIndex);\n      }\n\n      return true;\n    }\n  }\n\n  afterMoveActions(promotionIndex) {\n    this.checkIfPawnFirstMove(this.board.activePiece);\n    this.checkIfRookMoved(this.board.activePiece);\n    this.checkIfKingMoved(this.board.activePiece);\n    this.board.blackKingChecked = this.board.isKingInCheck(Color.BLACK, this.board.pieces);\n    this.board.whiteKingChecked = this.board.isKingInCheck(Color.WHITE, this.board.pieces);\n    const check = this.board.blackKingChecked || this.board.whiteKingChecked;\n    const checkmate = this.checkForPossibleMoves(Color.BLACK) || this.checkForPossibleMoves(Color.WHITE);\n    const stalemate = this.checkForPat(Color.BLACK) || this.checkForPat(Color.WHITE);\n    this.historyMoveCandidate.setGameStates(check, stalemate, checkmate);\n    this.pgnProcessor.processChecks(checkmate, check, stalemate);\n    this.pgnProcessor.addPromotionChoice(promotionIndex);\n    this.disabling = false;\n    this.board.calculateFEN();\n    const lastMove = this.moveHistoryProvider.getLastMove();\n\n    if (lastMove && promotionIndex) {\n      lastMove.move += promotionIndex;\n    }\n\n    this.moveChange.emit(Object.assign(Object.assign({}, lastMove), {\n      check,\n      checkmate,\n      stalemate,\n      fen: this.board.fen,\n      pgn: {\n        pgn: this.pgnProcessor.getPGN()\n      },\n      freeMode: this.freeMode\n    }));\n    this.moveDone = true;\n  }\n\n  checkForPat(color) {\n    if (color === Color.WHITE && !this.board.whiteKingChecked) {\n      return this.checkForPossibleMoves(color);\n    } else {\n      if (color === Color.BLACK && !this.board.blackKingChecked) {\n        return this.checkForPossibleMoves(color);\n      }\n    }\n  }\n\n  openPromoteDialog(piece) {\n    if (piece.color === this.board.activePiece.color) {\n      this.modal.open(index => {\n        PiecePromotionResolver.resolvePromotionChoice(this.board, piece, index);\n        this.afterMoveActions(index);\n      });\n    }\n  }\n\n  checkForPossibleMoves(color) {\n    return !this.board.pieces.filter(piece => piece.color === color).some(piece => piece.getPossibleMoves().some(move => !MoveUtils.willMoveCauseCheck(color, piece.point.row, piece.point.col, move.row, move.col, this.board)) || piece.getPossibleCaptures().some(capture => !MoveUtils.willMoveCauseCheck(color, piece.point.row, piece.point.col, capture.row, capture.col, this.board)));\n  }\n\n  disableSelection() {\n    this._selected = false;\n    this.board.possibleCaptures = [];\n    this.board.activePiece = null;\n    this.board.possibleMoves = [];\n  }\n  /**\r\n   * Processes logic to allow freeMode based logic processing\r\n   */\n\n\n  onFreeMode(pieceClicked) {\n    if (!this.freeMode || pieceClicked === undefined || pieceClicked === null) {\n      return;\n    } // sets player as white in-case white pieces are selected, and vice-versa when black is selected\n\n\n    this.board.currentWhitePlayer = pieceClicked.color === Color.WHITE;\n  }\n\n  isPieceDisabled(pieceClicked) {\n    if (pieceClicked && pieceClicked.point) {\n      const foundCapture = this.board.possibleCaptures.find(capture => capture.col === pieceClicked.point.col && capture.row === pieceClicked.point.row);\n\n      if (foundCapture) {\n        return false;\n      }\n    }\n\n    return pieceClicked && (this.lightDisabled && pieceClicked.color === Color.WHITE || this.darkDisabled && pieceClicked.color === Color.BLACK);\n  }\n\n  addDrawPoint(x, y, crtl, alt, shift, left, top) {\n    const upPoint = ClickUtils.getDrawingPoint(this.heightAndWidth, this.colorStrategy, x, y, crtl, alt, shift, left, top);\n\n    if (this.drawPoint.isEqual(upPoint)) {\n      const circle = new Circle();\n      circle.drawPoint = upPoint;\n\n      if (!this.drawProvider.containsCircle(circle)) {\n        this.drawProvider.addCircle(circle);\n      } else {\n        this.drawProvider.reomveCircle(circle);\n      }\n    } else {\n      const arrow = new Arrow();\n      arrow.start = this.drawPoint;\n      arrow.end = upPoint;\n\n      if (!this.drawProvider.containsArrow(arrow)) {\n        this.drawProvider.addArrow(arrow);\n      } else {\n        this.drawProvider.removeArrow(arrow);\n      }\n    }\n  }\n\n  increaseFullMoveCount() {\n    if (!this.board.currentWhitePlayer) {\n      ++this.board.fullMoveCount;\n    }\n  }\n\n  addPiece(pieceTypeInput, colorInput, coords) {\n    if (this.freeMode && coords && pieceTypeInput > 0 && colorInput > 0) {\n      let indexes = MoveUtils.translateCoordsToIndex(coords, this.board.reverted);\n      let existing = this.board.getPieceByPoint(indexes.yAxis, indexes.xAxis);\n\n      if (existing) {\n        this.board.pieces = this.board.pieces.filter(e => e !== existing);\n      }\n\n      let createdPiece = PieceFactory.create(indexes, pieceTypeInput, colorInput, this.board);\n      this.saveClone();\n      this.board.pieces.push(createdPiece);\n      this.afterMoveActions();\n    }\n  }\n\n}\n\nclass Board {\n  constructor() {\n    this.board = [];\n    this.pieces = [];\n    this.enPassantPoint = null;\n    this.enPassantPiece = null;\n    this.lastMoveSrc = null;\n    this.lastMoveDest = null;\n    this.possibleCaptures = [];\n    this.possibleMoves = [];\n    this.currentWhitePlayer = true;\n    this.reverted = false;\n    this.fullMoveCount = 1;\n\n    for (let i = 0; i < 8; ++i) {\n      this.board[i] = [];\n\n      for (let j = 0; j < 8; ++j) {\n        this.board[i][j] = 0;\n      }\n    }\n  }\n\n  isXYInPossibleMoves(row, col) {\n    return this.possibleMoves.some(move => move.row === row && move.col === col);\n  }\n\n  isXYInPossibleCaptures(row, col) {\n    return this.possibleCaptures.some(capture => capture.row === row && capture.col === col);\n  }\n\n  isXYInSourceMove(i, j) {\n    return this.lastMoveSrc && this.lastMoveSrc.row === i && this.lastMoveSrc.col === j;\n  }\n\n  isXYInDestMove(i, j) {\n    return this.lastMoveDest && this.lastMoveDest.row === i && this.lastMoveDest.col === j;\n  }\n\n  isXYInActiveMove(i, j) {\n    return this.activePiece && this.activePiece.point.row === i && this.activePiece.point.col === j;\n  }\n\n  isPointInPossibleMoves(point) {\n    return this.possibleMoves.some(move => move.row === point.row && move.col === point.col);\n  }\n\n  isPointInPossibleCaptures(point) {\n    return this.possibleCaptures.some(capture => capture.row === point.row && capture.col === point.col);\n  }\n\n  reset() {\n    this.lastMoveDest = null;\n    this.lastMoveSrc = null;\n    this.whiteKingChecked = false;\n    this.blackKingChecked = false;\n    this.possibleCaptures = [];\n    this.possibleMoves = [];\n    this.activePiece = null;\n    this.reverted = false;\n    this.currentWhitePlayer = true;\n    this.enPassantPoint = null;\n    this.enPassantPiece = null;\n    this.fullMoveCount = 1;\n    this.calculateFEN();\n  }\n\n  reverse() {\n    this.reverted = !this.reverted;\n    this.activePiece = null;\n    this.possibleMoves = [];\n    this.possibleCaptures = [];\n    this.pieces.forEach(piece => this.reversePoint(piece.point));\n    this.reversePoint(this.lastMoveSrc);\n    this.reversePoint(this.lastMoveDest);\n\n    if (this.enPassantPoint && this.enPassantPiece) {\n      this.reversePoint(this.enPassantPoint);\n    }\n  }\n\n  clone() {\n    return cloneDeep(this);\n  }\n\n  isFieldTakenByEnemy(row, col, enemyColor) {\n    if (row > 7 || row < 0 || col > 7 || col < 0) {\n      return false;\n    }\n\n    return this.pieces.some(piece => piece.point.col === col && piece.point.row === row && piece.color === enemyColor);\n  }\n\n  isFieldEmpty(row, col) {\n    if (row > 7 || row < 0 || col > 7 || col < 0) {\n      return false;\n    }\n\n    return !this.pieces.some(piece => piece.point.col === col && piece.point.row === row);\n  }\n\n  isFieldUnderAttack(row, col, color) {\n    return this.pieces.filter(piece => piece.color === color).some(piece => piece.getCoveredFields().some(field => field.col === col && field.row === row));\n  }\n\n  getPieceByField(row, col) {\n    if (this.isFieldEmpty(row, col)) {\n      //   throw new Error('Piece not found');\n      return undefined;\n    }\n\n    return this.pieces.find(piece => piece.point.col === col && piece.point.row === row);\n  }\n\n  isKingInCheck(color, pieces) {\n    const king = pieces.find(piece => piece.color === color && piece instanceof King);\n\n    if (king) {\n      return pieces.some(piece => piece.getPossibleCaptures().some(point => point.col === king.point.col && point.row === king.point.row) && piece.color !== color);\n    }\n\n    return false;\n  }\n\n  getKingByColor(color) {\n    return this.pieces.find(piece => piece instanceof King && piece.color === color);\n  }\n\n  getCastleFENString(color) {\n    const king = this.getKingByColor(color);\n\n    if (!king || king.isMovedAlready) {\n      return '';\n    }\n\n    let fen = '';\n    const leftRook = this.getPieceByField(king.point.row, 0);\n    const rightRook = this.getPieceByField(king.point.row, 7);\n\n    if (rightRook instanceof Rook && rightRook.color === color) {\n      if (!rightRook.isMovedAlready) {\n        fen += this.reverted ? 'q' : 'k';\n      }\n    }\n\n    if (leftRook instanceof Rook && leftRook.color === color) {\n      if (!leftRook.isMovedAlready) {\n        fen += this.reverted ? 'k' : 'q';\n      }\n    }\n\n    fen = fen.split('').sort().join('');\n    return color === Color.BLACK ? fen : fen.toUpperCase();\n  }\n\n  getEnPassantFENString() {\n    if (this.enPassantPoint) {\n      if (this.reverted) {\n        return String.fromCharCode(104 - this.enPassantPoint.col) + (this.enPassantPoint.row + 1);\n      } else {\n        return String.fromCharCode(97 + this.enPassantPoint.col) + (Math.abs(this.enPassantPoint.row - 7) + 1);\n      }\n    } else {\n      return '-';\n    }\n  }\n\n  calculateFEN() {\n    let fen = '';\n\n    for (let i = 0; i < 8; ++i) {\n      let emptyFields = 0;\n\n      for (let j = 0; j < 8; ++j) {\n        const foundPiece = this.pieces.find(piece => piece.point.col === j && piece.point.row === i);\n\n        if (foundPiece) {\n          if (emptyFields > 0) {\n            fen += emptyFields;\n            emptyFields = 0;\n          }\n\n          if (foundPiece instanceof Rook) {\n            fen += foundPiece.color === Color.BLACK ? 'r' : 'R';\n          } else {\n            if (foundPiece instanceof Knight) {\n              fen += foundPiece.color === Color.BLACK ? 'n' : 'N';\n            } else {\n              if (foundPiece instanceof Bishop) {\n                fen += foundPiece.color === Color.BLACK ? 'b' : 'B';\n              } else {\n                if (foundPiece instanceof Queen) {\n                  fen += foundPiece.color === Color.BLACK ? 'q' : 'Q';\n                } else {\n                  if (foundPiece instanceof King) {\n                    fen += foundPiece.color === Color.BLACK ? 'k' : 'K';\n                  } else {\n                    if (foundPiece instanceof Pawn) {\n                      fen += foundPiece.color === Color.BLACK ? 'p' : 'P';\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          ++emptyFields;\n        }\n      }\n\n      if (emptyFields > 0) {\n        fen += emptyFields;\n      }\n\n      fen += '/';\n    }\n\n    fen = fen.substr(0, fen.length - 1);\n\n    if (this.reverted) {\n      fen = fen.split('').reverse().join('');\n    }\n\n    fen += ' ' + (this.currentWhitePlayer ? 'w' : 'b');\n    const whiteEnPassant = this.getCastleFENString(Color.WHITE);\n    const blackEnPassant = this.getCastleFENString(Color.BLACK);\n    let concatedEnPassant = whiteEnPassant + blackEnPassant;\n\n    if (!concatedEnPassant) {\n      concatedEnPassant = '-';\n    }\n\n    fen += ' ' + concatedEnPassant;\n    fen += ' ' + this.getEnPassantFENString();\n    fen += ' ' + 0;\n    fen += ' ' + this.fullMoveCount;\n    this.fen = fen;\n  }\n\n  isXYInPointSelection(i, j) {\n    return false;\n  }\n\n  reversePoint(point) {\n    if (point) {\n      point.row = Math.abs(point.row - 7);\n      point.col = Math.abs(point.col - 7);\n    }\n  }\n\n  getPieceByPoint(row, col) {\n    row = Math.floor(row);\n    col = Math.floor(col);\n    return this.pieces.find(piece => piece.point.col === col && piece.point.row === row);\n  }\n\n  checkIfPawnTakesEnPassant(newPoint) {\n    if (newPoint.isEqual(this.enPassantPoint)) {\n      this.pieces = this.pieces.filter(piece => piece !== this.enPassantPiece);\n      this.enPassantPoint = null;\n      this.enPassantPiece = null;\n    }\n  }\n\n  checkIfPawnEnpassanted(piece, newPoint) {\n    if (Math.abs(piece.point.row - newPoint.row) > 1) {\n      this.enPassantPiece = piece;\n      this.enPassantPoint = new Point((piece.point.row + newPoint.row) / 2, piece.point.col);\n    } else {\n      this.enPassantPoint = null;\n      this.enPassantPiece = null;\n    }\n  }\n\n  isKingChecked(piece) {\n    if (piece instanceof King) {\n      return piece.color === Color.WHITE ? this.whiteKingChecked : this.blackKingChecked;\n    }\n  }\n\n  getCurrentPlayerColor() {\n    return this.currentWhitePlayer ? Color.WHITE : Color.BLACK;\n  }\n\n}\n\nlet NgxChessBoardService = /*#__PURE__*/(() => {\n  class NgxChessBoardService {\n    constructor() {\n      this.componentMethodCallSource = new Subject();\n      this.componentMethodCalled$ = this.componentMethodCallSource.asObservable();\n    }\n\n    reset() {\n      this.componentMethodCallSource.next();\n    }\n\n  }\n\n  NgxChessBoardService.ɵfac = function NgxChessBoardService_Factory(t) {\n    return new (t || NgxChessBoardService)();\n  };\n\n  NgxChessBoardService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxChessBoardService,\n    factory: NgxChessBoardService.ɵfac,\n    providedIn: 'root'\n  });\n  return NgxChessBoardService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet PiecePromotionModalComponent = /*#__PURE__*/(() => {\n  class PiecePromotionModalComponent {\n    constructor() {\n      this.color = 'white';\n      this.opened = false;\n    }\n\n    open(closeCallback) {\n      this.opened = true;\n      this.onCloseCallback = closeCallback;\n      this.modal.nativeElement.style.display = 'block';\n    }\n\n    changeSelection(index) {\n      this.modal.nativeElement.style.display = 'none';\n      this.opened = false;\n      this.onCloseCallback(index);\n    }\n\n    getPieceIcon(piece) {\n      let coloredPiece = '';\n\n      switch (piece.toLowerCase()) {\n        case 'queen':\n          coloredPiece = this.color === 'white' ? this.pieceIconInput.whiteQueenUrl : this.pieceIconInput.blackQueenUrl;\n          break;\n\n        case 'rook':\n          coloredPiece = this.color === 'white' ? this.pieceIconInput.whiteRookUrl : this.pieceIconInput.blackRookUrl;\n          break;\n\n        case 'bishop':\n          coloredPiece = this.color === 'white' ? this.pieceIconInput.whiteBishopUrl : this.pieceIconInput.blackBishopUrl;\n          break;\n\n        case 'knight':\n          coloredPiece = this.color === 'white' ? this.pieceIconInput.whiteKnightUrl : this.pieceIconInput.blackKnightUrl;\n          break;\n      }\n\n      return coloredPiece;\n    }\n\n  }\n\n  PiecePromotionModalComponent.ɵfac = function PiecePromotionModalComponent_Factory(t) {\n    return new (t || PiecePromotionModalComponent)();\n  };\n\n  PiecePromotionModalComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PiecePromotionModalComponent,\n    selectors: [[\"app-piece-promotion-modal\"]],\n    viewQuery: function PiecePromotionModalComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.modal = _t.first);\n      }\n    },\n    inputs: {\n      pieceIconInput: \"pieceIconInput\",\n      color: \"color\"\n    },\n    decls: 6,\n    vars: 2,\n    consts: [[1, \"container\"], [\"myModal\", \"\"], [1, \"wrapper\"], [1, \"content\"], [\"class\", \"piece-wrapper\", 4, \"ngIf\"], [1, \"piece-wrapper\"], [1, \"piece\", 3, \"click\"], [\"alt\", \"Queen\", 3, \"src\"], [\"alt\", \"Rook\", 3, \"src\"], [\"alt\", \"Bishop\", 3, \"src\"], [\"alt\", \"Knight\", 3, \"src\"]],\n    template: function PiecePromotionModalComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0, 1)(2, \"div\", 2)(3, \"div\", 3);\n        i0.ɵɵtemplate(4, PiecePromotionModalComponent_div_4_Template, 9, 4, \"div\", 4);\n        i0.ɵɵtemplate(5, PiecePromotionModalComponent_div_5_Template, 9, 0, \"div\", 4);\n        i0.ɵɵelementEnd()()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngIf\", ctx.pieceIconInput);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", !ctx.pieceIconInput);\n      }\n    },\n    directives: [i3.NgIf],\n    styles: [\".container[_ngcontent-%COMP%]{display:none;position:absolute;z-index:9999;top:0;color:#000;width:100%;height:100%;overflow:auto;background-color:#0006}.wrapper[_ngcontent-%COMP%]{position:relative;height:100%;width:100%}.content[_ngcontent-%COMP%]{background-color:#fefefe;margin:auto;position:relative;top:30%;font-size:100%;height:40%;padding:10px;border:1px solid #888;width:90%}.piece[_ngcontent-%COMP%]{font-size:5rem;height:100%;width:25%;cursor:pointer;display:inline-block;text-align:center}.piece[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{max-width:100%}.piece[_ngcontent-%COMP%]:hover{background-color:#ccc;border-radius:5px}.piece-wrapper[_ngcontent-%COMP%]{height:80%;width:100%}#close-button[_ngcontent-%COMP%]{border-radius:4px;background-color:#4caf50;border:none;color:#fff;padding-left:5px;padding-right:5px;text-align:center;text-decoration:none;display:inline-block}.selected[_ngcontent-%COMP%]{border:2px solid #00B919;border-radius:4px;box-sizing:border-box}\"]\n  });\n  return PiecePromotionModalComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgxChessBoardComponent = /*#__PURE__*/(() => {\n  class NgxChessBoardComponent {\n    constructor(ngxChessBoardService) {\n      this.ngxChessBoardService = ngxChessBoardService;\n      this.darkTileColor = Constants.DEFAULT_DARK_TILE_COLOR;\n      this.lightTileColor = Constants.DEFAULT_LIGHT_TILE_COLOR;\n      this.showCoords = true;\n      this.sourcePointColor = Constants.DEFAULT_SOURCE_POINT_COLOR;\n      this.destinationPointColor = Constants.DEFAULT_DESTINATION_POINT_COLOR;\n      this.legalMovesPointColor = Constants.DEFAULT_LEGAL_MOVE_POINT_COLOR;\n      this.showLastMove = true;\n      this.showLegalMoves = true;\n      this.showActivePiece = true;\n      this.showPossibleCaptures = true;\n      /**\r\n       * Enabling free mode removes turn-based restriction and allows to move any piece freely!\r\n       */\n\n      this.moveChange = new EventEmitter();\n      this.checkmate = new EventEmitter();\n      this.stalemate = new EventEmitter();\n      this.selected = false;\n      this.isDragging = false;\n      this.startTransition = '';\n      this.engineFacade = new EngineFacade(new Board(), this.moveChange);\n    }\n\n    set size(size) {\n      if (size && size >= Constants.MIN_BOARD_SIZE && size <= Constants.MAX_BOARD_SIZE) {\n        this.engineFacade.heightAndWidth = size;\n      } else {\n        this.engineFacade.heightAndWidth = Constants.DEFAULT_SIZE;\n      }\n\n      this.engineFacade.drawProvider.clear();\n      this.calculatePieceSize();\n    }\n\n    set freeMode(freeMode) {\n      this.engineFacade.freeMode = freeMode;\n    }\n\n    set dragDisabled(dragDisabled) {\n      this.engineFacade.dragDisabled = dragDisabled;\n    }\n\n    set drawDisabled(drawDisabled) {\n      this.engineFacade.drawDisabled = drawDisabled;\n    }\n\n    set pieceIcons(pieceIcons) {\n      this.engineFacade.pieceIconManager.pieceIconInput = pieceIcons;\n    }\n\n    set lightDisabled(lightDisabled) {\n      this.engineFacade.lightDisabled = lightDisabled;\n    }\n\n    set darkDisabled(darkDisabled) {\n      this.engineFacade.darkDisabled = darkDisabled;\n    }\n\n    onRightClick(event) {\n      event.preventDefault();\n    }\n\n    ngOnChanges(changes) {\n      if (changes.lightDisabled && this.lightDisabled && this.engineFacade.board.currentWhitePlayer || changes.darkDisabled && this.darkDisabled && !this.engineFacade.board.currentWhitePlayer) {\n        this.engineFacade.board.possibleCaptures = [];\n        this.engineFacade.board.possibleMoves = [];\n      }\n    }\n\n    ngOnInit() {\n      this.ngxChessBoardService.componentMethodCalled$.subscribe(() => {\n        this.engineFacade.reset();\n      });\n    }\n\n    ngAfterViewInit() {\n      this.engineFacade.modal = this.modal;\n      this.calculatePieceSize();\n    }\n\n    onMouseUp(event) {\n      this.engineFacade.onMouseUp(event, this.getClickPoint(event), this.boardRef.nativeElement.getBoundingClientRect().left, this.boardRef.nativeElement.getBoundingClientRect().top);\n    }\n\n    reverse() {\n      this.selected = false;\n      this.engineFacade.board.reverse();\n      this.engineFacade.coords.reverse();\n    }\n\n    updateBoard(board) {\n      this.engineFacade.board = board;\n      this.boardLoader.setEngineFacade(this.engineFacade);\n      this.engineFacade.board.possibleCaptures = [];\n      this.engineFacade.board.possibleMoves = [];\n    }\n\n    setFEN(fen) {\n      try {\n        this.engineFacade.boardLoader.setNotationProcessor(NotationProcessorFactory.getProcessor(NotationType.FEN));\n        this.engineFacade.boardLoader.loadFEN(fen);\n        this.engineFacade.board.possibleCaptures = [];\n        this.engineFacade.board.possibleMoves = [];\n        this.engineFacade.coords.reset();\n      } catch (exception) {\n        this.engineFacade.boardLoader.addPieces();\n      }\n    }\n\n    setPGN(pgn) {\n      try {\n        this.engineFacade.pgnProcessor.reset();\n        this.engineFacade.boardLoader.setNotationProcessor(NotationProcessorFactory.getProcessor(NotationType.PGN));\n        this.engineFacade.boardLoader.loadPGN(pgn);\n        this.engineFacade.board.possibleCaptures = [];\n        this.engineFacade.board.possibleMoves = [];\n        this.engineFacade.coords.reset();\n      } catch (exception) {\n        console.log(exception);\n        this.engineFacade.boardLoader.addPieces();\n      }\n    }\n\n    getFEN() {\n      return this.engineFacade.board.fen;\n    }\n\n    dragEnded(event) {\n      this.isDragging = false;\n      this.engineFacade.dragEndStrategy.process(event, this.engineFacade.moveDone, this.startTransition);\n    }\n\n    dragStart(event) {\n      this.isDragging = true;\n      let trans = event.source.getRootElement().style.transform.split(') '); //   this.startTrans= trans;\n\n      this.startTransition = trans.length === 2 ? trans[1] : trans[0];\n      this.engineFacade.dragStartStrategy.process(event);\n    }\n\n    onMouseDown(event) {\n      this.engineFacade.onMouseDown(event, this.getClickPoint(event), this.boardRef.nativeElement.getBoundingClientRect().left, this.boardRef.nativeElement.getBoundingClientRect().top);\n    }\n\n    getClickPoint(event) {\n      return ClickUtils.getClickPoint(event, this.boardRef.nativeElement.getBoundingClientRect().top, this.boardRef.nativeElement.getBoundingClientRect().height, this.boardRef.nativeElement.getBoundingClientRect().left, this.boardRef.nativeElement.getBoundingClientRect().width);\n    }\n\n    calculatePieceSize() {\n      this.pieceSize = this.engineFacade.heightAndWidth / 8;\n    }\n\n    getCustomPieceIcons(piece) {\n      return JSON.parse(`{ \"background-image\": \"url('${this.engineFacade.pieceIconManager.getPieceIcon(piece)}')\"}`);\n    }\n\n    move(coords) {\n      this.engineFacade.move(coords);\n    }\n\n    getMoveHistory() {\n      return this.engineFacade.getMoveHistory();\n    }\n\n    reset() {\n      this.engineFacade.reset();\n    }\n\n    undo() {\n      this.engineFacade.undo();\n    }\n\n    addPiece(pieceTypeInput, colorInput, coords) {\n      this.engineFacade.addPiece(pieceTypeInput, colorInput, coords);\n    }\n\n    getPGN() {\n      return this.engineFacade.pgnProcessor.getPGN();\n    }\n\n    dragMoved($event) {\n      let x = $event.pointerPosition.x - $event.source.getRootElement().parentElement.getBoundingClientRect().left - this.pieceSize / 2;\n      let y = $event.pointerPosition.y - $event.source.getRootElement().parentElement.getBoundingClientRect().top - this.pieceSize / 2;\n      $event.source.getRootElement().style.transform = 'translate3d(' + x + 'px, ' + y + 'px,0px)';\n    }\n\n    getTileBackgroundColor(i, j) {\n      let color = (i + j) % 2 === 0 ? this.lightTileColor : this.darkTileColor;\n\n      if (this.showLastMove) {\n        if (this.engineFacade.board.isXYInSourceMove(i, j)) {\n          color = this.sourcePointColor;\n        }\n\n        if (this.engineFacade.board.isXYInDestMove(i, j)) {\n          color = this.destinationPointColor;\n        }\n      }\n\n      return color;\n    }\n\n  }\n\n  NgxChessBoardComponent.ɵfac = function NgxChessBoardComponent_Factory(t) {\n    return new (t || NgxChessBoardComponent)(i0.ɵɵdirectiveInject(NgxChessBoardService));\n  };\n\n  NgxChessBoardComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgxChessBoardComponent,\n    selectors: [[\"ngx-chess-board\"]],\n    viewQuery: function NgxChessBoardComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c1, 5);\n        i0.ɵɵviewQuery(_c2, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.boardRef = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.modal = _t.first);\n      }\n    },\n    hostBindings: function NgxChessBoardComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"contextmenu\", function NgxChessBoardComponent_contextmenu_HostBindingHandler($event) {\n          return ctx.onRightClick($event);\n        });\n      }\n    },\n    inputs: {\n      darkTileColor: \"darkTileColor\",\n      lightTileColor: \"lightTileColor\",\n      showCoords: \"showCoords\",\n      sourcePointColor: \"sourcePointColor\",\n      destinationPointColor: \"destinationPointColor\",\n      legalMovesPointColor: \"legalMovesPointColor\",\n      showLastMove: \"showLastMove\",\n      showLegalMoves: \"showLegalMoves\",\n      showActivePiece: \"showActivePiece\",\n      showPossibleCaptures: \"showPossibleCaptures\",\n      size: \"size\",\n      freeMode: \"freeMode\",\n      dragDisabled: \"dragDisabled\",\n      drawDisabled: \"drawDisabled\",\n      pieceIcons: \"pieceIcons\",\n      lightDisabled: \"lightDisabled\",\n      darkDisabled: \"darkDisabled\"\n    },\n    outputs: {\n      moveChange: \"moveChange\",\n      checkmate: \"checkmate\",\n      stalemate: \"stalemate\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 13,\n    vars: 18,\n    consts: [[\"id\", \"board\", 3, \"pointerdown\", \"pointerup\"], [\"boardRef\", \"\"], [\"id\", \"drag\"], [\"class\", \"single-piece\", \"cdkDrag\", \"\", 3, \"cdkDragDisabled\", \"innerHTML\", \"ngStyle\", \"transform\", \"max-height\", \"font-size\", \"width\", \"height\", \"cdkDragEnded\", \"cdkDragMoved\", \"cdkDragStarted\", 4, \"ngFor\", \"ngForOf\"], [\"class\", \"board-row\", 4, \"ngFor\", \"ngForOf\"], [2, \"position\", \"absolute\", \"top\", \"0\", \"pointer-events\", \"none\"], [4, \"ngFor\", \"ngForOf\"], [\"class\", \"arrow\", 4, \"ngFor\", \"ngForOf\"], [\"fill-opacity\", \"0.0\", \"stroke-width\", \"2\", 4, \"ngFor\", \"ngForOf\"], [3, \"pieceIconInput\", \"color\"], [\"modal\", \"\"], [\"cdkDrag\", \"\", 1, \"single-piece\", 3, \"cdkDragDisabled\", \"innerHTML\", \"ngStyle\", \"cdkDragEnded\", \"cdkDragMoved\", \"cdkDragStarted\"], [1, \"board-row\"], [\"class\", \"board-col\", 3, \"current-selection\", \"king-check\", \"point-circle\", \"possible-capture\", \"possible-point\", \"background-color\", 4, \"ngFor\", \"ngForOf\"], [1, \"board-col\"], [\"class\", \"yCoord\", 3, \"color\", \"font-size\", 4, \"ngIf\"], [\"class\", \"xCoord\", 3, \"color\", \"font-size\", 4, \"ngIf\"], [\"style\", \"height:100%; width:100%\", 4, \"ngIf\"], [1, \"yCoord\"], [1, \"xCoord\"], [2, \"height\", \"100%\", \"width\", \"100%\"], [3, \"ngClass\"], [\"markerHeight\", \"13\", \"markerWidth\", \"13\", \"orient\", \"auto\", \"refX\", \"9\", \"refY\", \"6\", 3, \"id\"], [\"d\", \"M2,2 L2,11 L10,6 L2,2\"], [1, \"arrow\"], [\"fill-opacity\", \"0.0\", \"stroke-width\", \"2\"]],\n    template: function NgxChessBoardComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        const _r28 = i0.ɵɵgetCurrentView();\n\n        i0.ɵɵelementStart(0, \"div\", 0, 1);\n        i0.ɵɵlistener(\"pointerdown\", function NgxChessBoardComponent_Template_div_pointerdown_0_listener($event) {\n          i0.ɵɵrestoreView(_r28);\n\n          const _r6 = i0.ɵɵreference(12);\n\n          return !_r6.opened && ctx.onMouseDown($event);\n        })(\"pointerup\", function NgxChessBoardComponent_Template_div_pointerup_0_listener($event) {\n          i0.ɵɵrestoreView(_r28);\n\n          const _r6 = i0.ɵɵreference(12);\n\n          return !_r6.opened && ctx.onMouseUp($event);\n        });\n        i0.ɵɵelementStart(2, \"div\", 2);\n        i0.ɵɵtemplate(3, NgxChessBoardComponent_div_3_Template, 1, 13, \"div\", 3);\n        i0.ɵɵtemplate(4, NgxChessBoardComponent_div_4_Template, 2, 1, \"div\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵnamespaceSVG();\n        i0.ɵɵelementStart(5, \"svg\", 5);\n        i0.ɵɵtemplate(6, NgxChessBoardComponent__svg_defs_6_Template, 3, 3, \"defs\", 6);\n        i0.ɵɵtemplate(7, NgxChessBoardComponent__svg_line_7_Template, 1, 6, \"line\", 7);\n        i0.ɵɵpipe(8, \"async\");\n        i0.ɵɵtemplate(9, NgxChessBoardComponent__svg_circle_9_Template, 1, 4, \"circle\", 8);\n        i0.ɵɵpipe(10, \"async\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵnamespaceHTML();\n        i0.ɵɵelement(11, \"app-piece-promotion-modal\", 9, 10);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"height\", ctx.engineFacade.heightAndWidth, \"px\")(\"width\", ctx.engineFacade.heightAndWidth, \"px\");\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngForOf\", ctx.engineFacade.board.pieces);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.engineFacade.board.board);\n        i0.ɵɵadvance(1);\n        i0.ɵɵattribute(\"height\", ctx.engineFacade.heightAndWidth)(\"width\", ctx.engineFacade.heightAndWidth);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpureFunction0(17, _c3));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind1(8, 13, ctx.engineFacade.drawProvider.arrows$));\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind1(10, 15, ctx.engineFacade.drawProvider.circles$));\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"pieceIconInput\", ctx.engineFacade.pieceIconManager.pieceIconInput)(\"color\", ctx.engineFacade.board.getCurrentPlayerColor() ? \"white\" : \"black\");\n      }\n    },\n    directives: [PiecePromotionModalComponent, i3.NgForOf, i4.CdkDrag, i3.NgStyle, i3.NgIf, i3.NgClass],\n    pipes: [i3.AsyncPipe],\n    styles: [\"@charset \\\"UTF-8\\\";#board[_ngcontent-%COMP%]{font-family:Courier New,serif;position:relative}.board-row[_ngcontent-%COMP%]{display:block;width:100%;height:12.5%;position:relative}.board-col[_ngcontent-%COMP%]{position:relative;display:inline-block;width:12.5%;vertical-align:top;cursor:default;height:100%}.piece[_ngcontent-%COMP%]{height:100%;cursor:-webkit-grab;cursor:grab;width:100%;-moz-user-select:none;user-select:none;-webkit-user-select:none;background-size:cover;justify-content:center;text-align:center;color:#000!important;box-sizing:border-box}.piece[_ngcontent-%COMP%]:after{content:\\\"\\\\200b\\\";box-sizing:border-box}#drag[_ngcontent-%COMP%]{height:100%;width:100%}.possible-point[_ngcontent-%COMP%]{background:radial-gradient(#13262F 15%,transparent 20%)}.possible-point[_ngcontent-%COMP%]:hover, .possible-capture[_ngcontent-%COMP%]:hover{opacity:.4}.possible-capture[_ngcontent-%COMP%]{background:radial-gradient(transparent 0%,transparent 80%,#13262F 80%);opacity:.5;box-sizing:border-box;margin:0;padding:0}.king-check[_ngcontent-%COMP%]{background:radial-gradient(ellipse at center,red 0%,#e70000 25%,rgba(169,0,0,0) 89%,rgba(158,0,0,0) 100%)}.current-selection[_ngcontent-%COMP%]{background-color:#72620b!important}.yCoord[_ngcontent-%COMP%]{position:absolute;-moz-user-select:none;user-select:none;-webkit-user-select:none;cursor:pointer;right:.2em;font-family:Lucida Console,Courier,monospace;box-sizing:border-box}.xCoord[_ngcontent-%COMP%]{position:absolute;-moz-user-select:none;user-select:none;-webkit-user-select:none;cursor:pointer;left:.2em;bottom:0;font-family:Lucida Console,Courier,monospace;box-sizing:border-box}.hovering[_ngcontent-%COMP%]{background-color:red!important}.arrow[_ngcontent-%COMP%]{stroke-width:2}svg[_ngcontent-%COMP%]{filter:drop-shadow(1px 1px 0px #111) drop-shadow(-1px 1px 0px #111) drop-shadow(1px -1px 0px #111) drop-shadow(-1px -1px 0px #111)}[_nghost-%COMP%]{display:inline-block!important}.single-piece[_ngcontent-%COMP%]{position:absolute;z-index:999;justify-content:center;text-align:center;-moz-user-select:none;user-select:none;-webkit-user-select:none;color:#000!important;cursor:-webkit-grab;cursor:grab;background-size:cover}.single-piece[_ngcontent-%COMP%]:after{content:\\\"\\\\200b\\\";box-sizing:border-box}.cdk-drag[_ngcontent-%COMP%]:not(.cdk-drag-dragging){transition:transform .2s cubic-bezier(0,.3,.14,.49)}\"]\n  });\n  return NgxChessBoardComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgxChessBoardModule = /*#__PURE__*/(() => {\n  class NgxChessBoardModule {\n    static forRoot() {\n      return {\n        ngModule: NgxChessBoardModule,\n        providers: [NgxChessBoardService]\n      };\n    }\n\n  }\n\n  NgxChessBoardModule.ɵfac = function NgxChessBoardModule_Factory(t) {\n    return new (t || NgxChessBoardModule)();\n  };\n\n  NgxChessBoardModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxChessBoardModule\n  });\n  NgxChessBoardModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, DragDropModule]]\n  });\n  return NgxChessBoardModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\r\n * Public API Surface of ngx-chess-board\r\n */\n\n/*\r\n * Public API Surface of im-grid\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { HistoryMove, NgxChessBoardComponent, NgxChessBoardModule, NgxChessBoardService, PiecePromotionModalComponent }; //# sourceMappingURL=ngx-chess-board.mjs.map","map":null,"metadata":{},"sourceType":"module"}